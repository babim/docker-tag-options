#  ____        _     _
# | __ )  __ _| |__ (_)_ __ ___
# |  _ \ / _` | '_ \| | '_ ` _ \
# | |_) | (_| | |_) | | | | | | |
# |____/ \__,_|_.__/|_|_| |_| |_|


    ####### START #######
    #####################

# # Stop script on NZEC
# set -e
# # Stop script if unbound variable found (use ${var:-} if intentional)
# set -u
# # By default cmd1 | cmd2 returns exit code of cmd2 regardless of cmd1 success
# # This is causing it to fail
# set -o pipefail

# set variables
    memory=$(grep 'MemTotal' /proc/meminfo |tr ' ' '\n' |grep [0-9])
    declare -r TRUE=0
    declare -r FALSE=1
    declare -r PASSWD_FILE=/etc/passwd


    ####### Set Color echo #######
    ##############################

# Use in the the functions: eval $invocation
invocation='say_verbose "Calling: ${yellow:-}${FUNCNAME[0]} ${green:-}$*${normal:-}"'

# standard output may be used as a return value in the functions
# we need a way to write text on the screen in the functions so that
# it won't interfere with the return value.
# Exposing stream 3 as a pipe to standard output of the script itself
exec 3>&1

# Setup some colors to use. These need to work in fairly limited shells, like the Ubuntu Docker container where there are only 8 colors.
# See if stdout is a terminal
    if [ -t 1 ] && command -v tput > /dev/null; then
        # see if it supports colors
        ncolors=$(tput colors)
        if [ -n "$ncolors" ] && [ $ncolors -ge 8 ]; then
            bold="$(tput bold       || echo)"
            normal="$(tput sgr0     || echo)"
            black="$(tput setaf 0   || echo)"
            red="$(tput setaf 1     || echo)"
            green="$(tput setaf 2   || echo)"
            yellow="$(tput setaf 3  || echo)"
            blue="$(tput setaf 4    || echo)"
            magenta="$(tput setaf 5 || echo)"
            cyan="$(tput setaf 6    || echo)"
            white="$(tput setaf 7   || echo)"
        fi
    fi

####### Echo Warning #######
function    say_warning()
    {
        printf "%b\n" "${yellow:-} Warning: $@${normal:-}"
    }

####### Echo Error #######
function    say_err()
    {
        printf "%b\n" "${red:-} Error: $@${normal:-}" >&2
    }

####### Echo Normal #######
function    say()
    {
        # which may be used as return value
        printf "%b\n" "${cyan:-} ${normal:-} $@"
    }

####### Echo verbose #######
function    say_verbose()
    {
        if [ "$verbose" = true ]; then
            say "$1"
        fi
    }


    ####### Change path #######
    ###########################

# input - $1
function    to_lowercase()
    {
        #eval $invocation

        echo "$@" | tr '[:upper:]' '[:lower:]'
        return $TRUE
    }

function    to_uppercase()
    {
        #eval $invocation

        echo "$@" | tr '[:lower:]' '[:upper:]'
        return $TRUE
    }

# args:
# input - $1
function    remove_trailing_slash()
    {
        #eval $invocation

        local input="${1:-}"
        echo "${input%/}"
        return $TRUE
    }

# args:
# input - $1
function    remove_beginning_slash()
    {
        #eval $invocation

        local input="${1:-}"
        echo "${input#/}"
        return $TRUE
    }

# args:
# root_path - $1
# child_path - $2 - this parameter can be empty
function    combine_paths()
    {
        eval $invocation

        # TODO: Consider making it work with any number of paths. For now:
        if [ ! -z "${3:-}" ]; then
            say_err "combine_paths: Function takes two parameters."
            return $FALSE
        fi

        local root_path="$(remove_trailing_slash "$1")"
        local child_path="$(remove_beginning_slash "${2:-}")"
        say_verbose "combine_paths: root_path=$root_path"
        say_verbose "combine_paths: child_path=$child_path"
        echo "$root_path/$child_path"
        return $TRUE
    }


    ####### Check and run from URL #######
    ######################################

####### machine has (check packages bin run) #######
function    machine_has()
    {
        eval $invocation

        hash "$1" > /dev/null 2>&1
        return $?
    }

####### Run from URL #######
function    run_url()
    {
        bash <(curl -s $1)
    }

####### Download file #######
# download_with_curl /winrar.zip http://media.matmagoc.com/winrar.zip
function    download_with_curl()
    {
        FILETEMP="$1"
        [[ -f $FILETEMP ]] && rm -f $FILETEMP
            echo "downloading and update..."
            curl -Ls "$2" -o "$FILETEMP"
    }
# download_with_wget /winrar.zip http://media.matmagoc.com/winrar.zip
function    download_with_wget()
    {
        FILETEMP="$1"
        [[ -f $FILETEMP ]] && rm -f $FILETEMP
            echo "downloading and update..."
            wget -O $FILETEMP --no-check-certificate "$2"
    }


    ####### Get Linux distribution #######
    ######################################

# os name
function    get_osname()
    {
    eval $invocation

    local uname=$(uname)
    if [ "$uname" = "Darwin" ]; then
        echo "osx"
        return $TRUE
    elif [ "$uname" = "FreeBSD" ]; then
        echo "freebsd"
        return $TRUE        
    elif [ "$uname" = "Linux" ]; then
        if [ -e /etc/os-release ] && [ ! -e /etc/redhat-release ]; then
            . /etc/os-release
            echo "$ID.$VERSION_ID"
            return $TRUE
        elif [ -e /etc/redhat-release ]; then
            local redhatRelease=$(</etc/redhat-release)
            if [[ $redhatRelease == "CentOS release 6."*    || $redhatRelease == "Red Hat Enterprise Linux Server release 6."* ]]; then
                echo "rhel.6"
                return $TRUE
            elif [[ $redhatRelease == "CentOS release 7."*  || $redhatRelease == "Red Hat Enterprise Linux Server release 7."* ]]; then
                echo "rhel.7"
                return $TRUE
            elif [[ $redhatRelease == "CentOS release 5."*  || $redhatRelease == "Red Hat Enterprise Linux Server release 5."* ]]; then
                echo "rhel.5"
                return $TRUE
            fi

            say_verbose "Linux specific platform name and version could not be detected: UName = $uname"
            return $FALSE
        fi

    say_err "OS name could not be detected: UName = $uname"
    return $FALSE
    fi    
    }

# check debian need update
function    check_debian_need_update()
    {
        [[ ! -z /var/lib/apt/lists/ ]] && return $TRUE || return $FALSE
    }

    # release name
    [[ -f /etc/debian_version ]]    && release=$(cat /etc/debian_version|grep -o [0-9]|head -n1)
    # codename
    [[ -f /etc/os-release ]]        && codename="$(cat /etc/os-release |grep VERSION= |cut -f 2 -d \(|cut -f 1 -d \))"


    ####### Get architecture #######
    ################################

# simple machine architecture
    arch=$(uname -i)

# dpkg architecture
function    check_dpkg()
    {
        if machine_has dpkg; then
            say "DPKG installed" 
            dpkg --print-architecture | awk -F- '{ print $NF }'
            return $TRUE
        else
            say_err "DPKG not found"
            return $FALSE
        fi
    }
function    dpkgArch()
    {
        if [[ ! -f /usr/bin/dpkg ]]; then
            osname=$(get_osname)
                # redhat
                if [[ $osname == "rhel"* ]]; then 
                    [[ ! -f /usr/bin/dpkg ]]        && yum install -y dpkg
                    check_dpkg
                # ubuntu
                elif [[ $osname == "ubuntu"* ]] || [[ $osname == "debian"* ]]; then
                    if check_debian_need_update     && [[ ! -f /usr/bin/dpkg ]]; then
                        apt-get install -y dpkg
                    elif ! check_debian_need_update && [[ ! -f /usr/bin/dpkg ]]; then
                        apt-get update              && apt-get install -y dpkg
                    fi
                    check_dpkg
                # alpine
                elif [[ $osname == "alpine"* ]]; then
                    [[ ! -f /usr/bin/dpkg ]]        && apk add --no-cache dpkg
                    check_dpkg
                else
                    say_err "Your OS not support"
                    return $FALSE
                fi
        fi
            dpkg --print-architecture | awk -F- '{ print $NF }'
            return $TRUE
    }

# machine architecture
function    get_machine_architecture()
    {
        eval $invocation

        if command -v uname > /dev/null; then
            CPUName=$(uname -m)
            case $CPUName in
            armv7l|arm)
                echo "arm"
                return $TRUE
                ;;
            aarch64|arm64)
                echo "arm64"
                return $TRUE
                ;;
            amd64|x64|x86_64)
                echo "x64"
                return $TRUE
                ;;
            x86)
                echo "x86"
                return $TRUE
                ;;
            esac
        fi

        # Always default to 'x64'
        # echo "x64"
        # return $TRUE
    }


    ####### User check, add, del #######
    ####################################

####### add a user #######
function    add_a_user()
    {
        USER=$1
        PASSWORD=$2
        shift; shift;
        # Having shifted twice, the rest is now comments ...
        COMMENTS=$@
        echo "Adding user $USER ..."
        echo useradd -c "$COMMENTS" $USER
        echo passwd $USER $PASSWORD
        echo "Added user $USER ($COMMENTS) with pass $PASSWORD"
    }

##################################################################
# Purpose: Return true if script is executed by the root user
# Arguments: none
# Return: True or False
# Invoke the is_root()
# is_root && echo "You are logged in as root." || echo "You are not logged in as root."
##################################################################
function    is_root() 
    {
        [ $(id -u) -eq 0 ] && return $TRUE || return $FALSE
    }
function    is_root_say() 
    {
        [ $(id -u) -eq 0 ] && say "You are logged in as root." || say_warning "You are not logged in as root."
    }
function    require_root()
    {
        # check permission root
        say "Check root"
            if [ "x$(id -u)" != 'x0' ]; then
                echo 'Error: this script can only be executed by root'
                exit 1
            fi
        say "You are logged in as root."
    }
##################################################################
# Purpose: Return true $user exits in /etc/passwd
# Arguments: $1 (username) -> Username to check in /etc/passwd
# Return: True or False
# Find out if user account vivek exits or not
# is_user "vivek" && echo "Account found." || echo "Account not found."
##################################################################
function    is_user() 
    {
        local u="$1"
        grep -q "^${u}" $PASSWD_FILE && return $TRUE || return $FALSE
    }
function    is_user_say() 
    {
        for isuser in "${@}"; do
            is_user ${isuser} && say "Account ${isuser} found." || say_warning "Account ${isuser} not found."
        done
    }


    ####### Function Feature #######
    ################################

####### Generate password #######
function    gen_passwd () 
    { 
        local l=$1;
        [ "$l" == "" ] && l=16;
        tr -dc A-Za-z0-9_ < /dev/urandom | head -c ${l} | xargs
    }

####### reload the nginx web server #######
function    reload_nginx()
    {
            /usr/local/nginx/sbin/nginx -s reload && say 'nginx server reloaded.' || say_err 'nginx server reload failed.'
    }

####### Copy file folder #######
function    copy_files_or_dirs_from_list()
    {
        eval $invocation

        local root_path="$(remove_trailing_slash "$1")"
        local out_path="$(remove_trailing_slash "$2")"
        local override="$3"
        local override_switch=$(if [ "$override" = false ]; then printf -- "-n"; fi)
        
        cat | uniq | while read -r file_path; do
            local path="$(remove_beginning_slash "${file_path#$root_path}")"
            local target="$out_path/$path"
            if [ "$override" = true ] || (! ([ -d "$target" ] || [ -e "$target" ])); then
                mkdir -p "$out_path/$(dirname "$path")"
                cp -R $override_switch "$root_path/$path" "$target"
            fi
        done
    }

# Defning return code check function
function    die()
    {
        if [[ $1 -ne 0 ]]; then
            echo "Error: $2"
            exit $1
        fi
    }

# calculator
function    calc()
    {
        ((cipher=$1))
        echo $cipher
        return $TRUE
    }

# read line
function    read_line()
    {
        n=1
        while read line; do
            # reading each line
            echo "Line $n : $line"
            n=$((n+1))
        done < $1
        return $TRUE
    }

# count line
function    count_line()
    {
        if [ $# -lt 1 ]; then
            echo "Usage: $0 file ..."
            exit 1
        fi

        echo "$0 counts the lines of code" 
            l=0
            n=0
            s=0

        for f in $*; do
            if [ -O $f ] # checks whether file owner is running the script
        then 
            l=`wc -l $f | sed 's/^\([0-9]*\).*$/\1/'`
            echo "$f: $l"
            n=$[ $n + 1 ]
            s=$[ $s + $l ]
        else
            continue
        fi
        done

        echo "$n files in total, with $s lines in total"
        return $TRUE
    }

#loading
function    loading()
    {
        for a in `seq 1 $1`; do
            echo "Loading: $a/$1" 
            sleep 1;
        done

        echo "!!! Done !!!"
        return $TRUE
    }

# check Greater Lesser
function    check_greater()
    {
        if [ $1 -gt $2 ]; then
            echo "$1 > $2"
        elif [ $1 -lt $2 ]; then
            echo "$1 < $2"
        fi
        return $TRUE
    }

# print date and time
function    print_date()
    {
        echo "Today is `date +"%A %d %B %Y (%r)"`"
        return $TRUE
    }

####### Check file and folder #######
function    check_file_block_special()
    {
        [[ -b $1 ]] && return $TRUE || return $FALSE

    }
function    check_file_special_character()
    {
        [[ -c $1 ]] && return $TRUE || return $FALSE
    }
function    check_dir()
    {
        [[ -d $1 ]] && return $TRUE || return $FALSE
    }
alias check_folder=check_dir
function    check_filefolder()
    {
        [[ -e $1 ]] && return $TRUE || return $FALSE
    }
function    check_filefolder_say()
    {
    for filefolder in "${@}"; do
        check_filefolder ${filefolder} && say "File/Folder ${filefolder} exists." || say_warning "File/Folder ${filefolder} does not exists."
    done
        return $TRUE
    }
function    check_file()
    {
        [[ -f $1 ]] && return $TRUE || return $FALSE
    }
function    check_file_owned_groupid()
    {
        [[ -G $1 ]] && return $TRUE || return $FALSE
    }
function    check_file_groupid()
    {
        [[ -g $1 ]] && return $TRUE || return $FALSE
    }
function    check_file_sticky()
    {
        [[ -k $1 ]] && return $TRUE || return $FALSE
    }
function    check_file_symlink()
    {
        [[ -L $1 ]] && return $TRUE || return $FALSE
    }
function    check_file_owned_userid()
    {
        [[ -O $1 ]] && return $TRUE || return $FALSE
    }
function    check_file_read()
    {
        [[ -r $1 ]] && return $TRUE || return $FALSE
    }
function    check_file_socket()
    {
        [[ -S $1 ]] && return $TRUE || return $FALSE
    }
function    check_file_nonzero()
    {
        [[ -s $1 ]] && return $TRUE || return $FALSE
    }
function    check_file_userid()
    {
        [[ -u $1 ]] && return $TRUE || return $FALSE
    }
function    check_file_write()
    {
        [[ -w $1 ]] && return $TRUE || return $FALSE
    }
function    check_file_run()
    {
        [[ -x $1 ]] && return $TRUE || return $FALSE
    }

# create dir
function    create_folder()
    {
        for folder in "${@}"; do
            if check_folder ${folder}; then
                say_warning "${folder} exists"
            else
                say "Creating ${folder}.."
                mkdir -p "${folder}"
                check_folder ${folder}      && say "${folder} created" || return $FALSE
            fi
        done
        return $TRUE
    }
# create file
function    create_file()
    {
        for file in "${@}"; do
            if check_file ${file}; then
                say_warning "${file} exists"
            else
                say "Creating ${file}.."
                touch "${file}"
                check_file ${file}          && say "${file} created" || return $FALSE
            fi
        done
        return $TRUE
    }

# set filefolder owner
function    set_filefolder_owner()
    {
        check_filefolder $2                 && chown -R $1 $2 || say "Cant set owner"
        return $TRUE
    }
# set filefolder mod
function    set_filefolder_mod()
    {
        check_filefolder $2                 && chmod -R $1 $2 || say "Cant set mod"
        return $TRUE
    }

# check process
function    check_process()
    {
        grep -x $1 >/dev/null               && return $TRUE || return $FALSE
    }
function    check_process_say()
    {
        for process in "${@}"; do
            grep -x $process >/dev/null     && say "Process found" || say_warning "Process not found"
        done
        return $TRUE
    }


    ####### Function Install #######
    ################################

# check and install epel
function    check_epel()
    {
        [[ -f /etc/yum.repos.d/epel.repo ]] && return $TRUE || return $FALSE
    }
function    check_epel_say()
    {
        [[ -f /etc/yum.repos.d/epel.repo ]] && say "EREL REPO installed" || say_warning "EREL REPO not found"
    }
function    install_epel()
    {
    if ! check_epel; then
        say "EPEL Repo not found"
        osname=$(get_osname)
            if [[ $osname == "rhel.6" ]]; then 
                yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm
            elif [[ $osname == "rhel.7" ]]; then 
                yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
            elif [[ $osname == "rhel.5" ]]; then 
                yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-5.noarch.rpm
            else
                say_err "Your OS not support"
                return $FALSE
            fi
        check_epel          && say "EREL REPO installed" || say_err "EREL REPO not found"
        check_epel          && return $TRUE || return $FALSE
    else
        say "EPEL Repo installed"
        return $TRUE
    fi
    }
function    remove_epel()
    {
        if ! check_epel; then
            say "EPEL Repo not found"
            return $TRUE
        else
            say "EPEL Repo installed"
            yum remove epel* -y
            check_epel          && say "EREL REPO removed" || say_err "EREL REPO found and cant removed"
            check_epel          && return $TRUE || return $FALSE
        fi
    }

# Gosu
function    install_gosu()
    {
    GOSU_VERSION=1.11
    # install gosu on your OS linux
    if machine_has gosu; then
        say "GOSU installed."
        return $TRUE
    else
        osname=$(get_osname)
            if [[ $osname == "ubuntu"* || $osname == "debian"* || $osname == "alpine"* ]]; then 
                FILETEMP=/usr/local/bin/gosu
            elif [[ $osname == "rhel"* ]]; then
                FILETEMP=/usr/bin/gosu
            else
                say_err "OS not support."
                return $FALSE
            fi

        curl -Ls "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkgArch)" -o ${FILETEMP}
        [[ ! -f ${FILETEMP} ]]  && return $FALSE
        chmod +x ${FILETEMP}    && gosu nobody true
        say "GOSU installed."
        return $TRUE
    fi
    }

# install package
function    install_package()
    {
        for software in ${@}; do
            osname=$(get_osname)
            say "install ${software}.."
                if [[ $osname == "ubuntu"* || $osname == "debian"*; then
                    check_debian_need_update && apt-get update || say "no need update repo"
                    apt-get install -y --no-install-recommends ${software}
                elif [[ $osname == "rhel"* ]]; then
                    yum install -y ${software}
                elif || $osname == "alpine"* ]]; then
                    apk add --no-cache install ${software}
                else
                    say_err "OS not support."
                    return $FALSE
                fi
            return $TRUE
        done
    }
# install package run bin
function    install_package_run()
    {
        for software in ${@}; do
            if ! machine_has ${software}; then
                osname=$(get_osname)
                say "install ${software}.."
                    if [[ $osname == "ubuntu"* || $osname == "debian"*; then
                        check_debian_need_update && apt-get update || say "no need update repo"
                        apt-get install -y --no-install-recommends ${software}
                    elif [[ $osname == "rhel"* ]]; then
                        yum install -y ${software}
                    elif || $osname == "alpine"* ]]; then
                        apk add --no-cache install ${software}
                    else
                        say_err "OS not support."
                        return $FALSE
                    fi
            fi

            machine_has ${software}          && say "${software} installed." || say_err "${software} not install."
            machine_has ${software}          && return $TRUE || return $FALSE
        done
    }

# install curl
function    install_curl()
    {
        software=curl
        install_package_run
    }

# install wget
function    install_wget()
    {
        software=wget
        install_package_run
    }

# install openjdk java jre
function    install_java_jre()
    {
            OPENJDKV=${OPENJDKV:-8}
    export  JAVA_HOME=/usr/lib/jvm/java-1.${OPENJDKV}-openjdk/jre
	export  PATH=$PATH:/usr/lib/jvm/java-1.${OPENJDKV}-openjdk/jre/bin:/usr/lib/jvm/java-1.${OPENJDKV}-openjdk/bin
        if ! check_folder /usr/lib/jvm/java-1.${OPENJDKV}-openjdk/jre; then
        osname=$(get_osname)
            say "install java.."
                if [[ $osname == "ubuntu"* || $osname == "debian"*; then
                    software=openjdk-${OPENJDKV}-jre
                    check_debian_need_update && apt-get update || say "no need update repo"
                    apt-get install -y --no-install-recommends ${software}
                elif [[ $osname == "rhel"* ]]; then
                    software=java-1.${OPENJDKV}.0-openjdk.${arch}
                    yum install -y ${software}
                elif || $osname == "alpine"* ]]; then
                    software=openjdk${OPENJDKV}-jre
                    apk add --no-cache install ${software}
                else
                    say_err "OS not support."
                    return $FALSE
                fi
            return $TRUE
        fi
    }