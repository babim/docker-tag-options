#!/bin/bash
#  ____        _     _
# | __ )  __ _| |__ (_)_ __ ___
# |  _ \ / _` | '_ \| | '_ ` _ \
# | |_) | (_| | |_) | | | | | | |
# |____/ \__,_|_.__/|_|_| |_| |_|

# this script checks to see if bash is running and if the version is >= 3.3
if [[ "${#BASH_VERSINFO[@]}" -eq 0 ||
        ${BASH_VERSINFO[0]}  -lt 3 ||
      ( ${BASH_VERSINFO[0]}  -eq 3 && ${BASH_VERSINFO[1]} -lt 3 ) ]]
then
  echo 1>&2 "This script can only run with bash version >= 3.3"
  if [[ -n "$BASH_VERSION" ]]; then
    echo 1>&2 "This is bash $BASH_VERSION"
  else
    echo 1>&2 "This is not bash!"
  fi
  exit 75           # EPROGMISMATCH
fi

    ####### START #######
    #####################

# # Stop script on NZEC
# set -e
# # Stop script if unbound variable found (use ${var:-} if intentional)
# set -u
# # By default cmd1 | cmd2 returns exit code of cmd2 regardless of cmd1 success
# # This is causing it to fail
# set -o pipefail

    ####### USE FOR BASH SCRIPT NEED LOAD THIS LIBRARY #######
    ##########################################################
# #####################################
#     ####### Set download tool #######
#     ####### and load library ########
# # check has package
# function    machine_has() {
#         hash "${1}" > /dev/null 2>&1
#         return $?; }
# # Check and set download tool
# echo "Check and set download tool..."
# if machine_has "curl"; then
#     source <(curl -s https://raw.githubusercontent.com/babim/docker-tag-options/master/lib/libbash)
# elif machine_has "wget"; then
#     source <(wget -qO- https://raw.githubusercontent.com/babim/docker-tag-options/master/lib/libbash)
# else
#     echo "without download tool"
#     sleep 3
#     exit 1
# fi
# download_option
# #####################################

    ####### Content #######
    #######################
function export_all()
    {
    # set start
        export -f debian_cmd_interface Clear
    # set text color
        export -f e_header e_arrow e_success e_error e_warning e_underline e_bold e_note say_warning say_err say
    # check has value
        export -f machine_has has_value has_empty \
                    has_equal has_not_equal has_equal_less has_equal_greater has_less has_greater \
                    check_value_true check_value_trues check_value_trues_say \
                    check_value_false check_value_falses check_value_falses_say
    # processing text
        export -f arg_input url_encode url_decode html_encode html_decode
    # download tool
        export -f download_with_curl download_with_wget download_option
    # change path
        export -f to_lowercase to_uppercase trim remove_trailing_slash remove_beginning_slash combine_paths
    # run from url
        export -f run_url
    # get os name
        export -f get_osname check_debian_need_update
    # Get architecture
        export -f check_dpkg dpkgArch get_machine_architecture
    # User check, add, del
        export -f add_a_user is_root is_root_say require_root is_user is_user_say
    # Time Feature
        export -f now elapsed start_watch stop_watch
    # Function Feature
        export -f gen_passwd reload_nginx copy_files_or_dirs_from_list dircopy die calc read_line count_line \
                    loading check_greater print_date
    # Check file and folder
        export -f dircmp findfile  str_replace_in_file findstr is_newer hex2decimal is_numeric check_process check_process_say \
                    \
                    check_file_block check_file_special_character check_folder check_filefolder check_file_owned_groupid \
                    check_file_groupid check_file_sticky check_file_symlink check_file_owned_userid check_file_read \
                    check_file_socket check_file_nonzero check_file_userid check_file_write check_file_run \
                    check_files_block check_files_block_say check_files_special_character check_files_special_character_say \
                    check_folders check_folders_say check_filefolders check_filefolders_say check_files check_files_say \
                    check_files_owned_groupid check_files_owned_groupid_say check_files_groupid check_files_groupid_say \
                    check_files_sticky check_files_sticky_say check_files_symlink check_files_symlink_say check_files_owned_userid \
                    check_files_owned_userid_say check_files_read check_files_read_say check_files_socket check_files_socket_say \
                    check_files_nonzero check_files_nonzero_say check_files_userid check_files_userid_say check_files_write \
                    check_files_write_say check_files_run check_files_run_say check_folder_empty check_folders_empty check_folders_empty_say \
                    \
		            core_command_check_value core_command_create_object core_command_remove_object core_command_set_object \
                    \
		            create_folders create_files create_folder create_file create_symlink \
		            \
                    remove_folders remove_files remove_filefolders remove_symlink remove_symlinks \
                    \
                    set_files_owner set_folders_owner set_filefolders_owner set_file_owner set_folder_owner set_filefolder_owner \
                    \
                    set_filefolders_mod set_folders_mod set_files_mod set_file_mod set_folder_mod set_filefolder_mod \
                    \
                    rsync_folder rsync_os rsync_folder_from_ssh rsync_os_from_ssh rsync_folder_to_ssh rsync_os_to_ssh \
		            \
		            tar_folder tar_file tar_filefolder tar_folder_ssh tar_file_ssh tar_filefolder_ssh \
                    tar_extract tar_extract_ssh unzip_extract unzip_extract_ssh \
		            \
                    scp_folder scp_to_ssh scp_from_ssh tar_copy_compress_ssh tar_copy_ssh
    # Function Install
        export -f update_os core_command_install check_epel check_epel_say \
                    install_package install_package_run install_packages install_packages_run \
		            \
		            core_command_debian_repo debian_add_repo debian_add_repos debian_add_repo_key debian_add_repo_keys \
		            debian_list_repo_key debian_remove_repo_key debian_remove_repo_keys \
                    \
		            install_tar install_rsync install_unzip install_js-yaml install_gosu install_sudo install_curl install_wget \
                    install_epel install_desktop_minimal install_java_jre install_supervisor install_js-yaml install_dmidecode \
                    install_php_composer
    # Function Remove
        export -f core_command_remove clean_os clean_package remove_package remove_packages remove_package_run remove_packages_run \
                    \
	                remove_epel debian_remove_repo debian_remove_repos remove_desktop_minimal remove_java_jre remove_gosu remove_sudo \
                    remove_js-yaml remove_supervisor remove_tar remove_rsync remove_unzip remove_dmidecode remove_download_tool \
                    remove_php_composer
    # Group: Network
        export -f is_ipv4 is_fqdn is_ipv4_netmask is_ipv4_cidr is_ipv4_subnet get_ipv4_network get_ipv4_broadcast mask2cidr cidr2mask
    }

# set commandline interface for debian
function    debian_cmd_interface()
    {
        export DEBIAN_FRONTEND=noninteractive
    }

# set variables
    export memory=$(grep 'MemTotal' /proc/meminfo |tr ' ' '\n' |grep [0-9])
    declare -r export TRUE=0
    declare -r export FALSE=1
    declare -r export PASSWD_FILE=/etc/passwd
    declare -r export date_day=$(date +%d%m%Y)
    declare -r export date_time=$(date +%Y%m%dT%H%M)
    declare -r export date_timezone=$(date +%Y%m%dT%H%MZ%z)

#    Clear - clear the terminal screen
function    Clear()
    {
        # SYNOPSIS
        #    Clear
        #
        # DESCRIPTION
        #    This function will clear the terminal screen using
        #    either the clear command or the tput command.  If
        #    neither of these commands are available, 40 blank
        #    lines will be printed to clear the screen.
        #
        { clear;       } 2>/dev/null  ||
        { tput clear;  } 2>/dev/null  ||
        for i in 1 2 3 4 5 6 7 8 9 10 \
                1 2 3 4 5 6 7 8 9 20 \
                1 2 3 4 5 6 7 8 9 30 \
                1 2 3 4 5 6 7 8 9 40
        do
            echo
        done
    }


    ####### Set Color echo #######
    ##############################

# Use in the the functions: eval $invocation
export invocation='say "Calling: ${yellow:-}${FUNCNAME[0]} ${green:-}$*${normal:-}"'

# standard output may be used as a return value in the functions
# we need a way to write text on the screen in the functions so that
# it won't interfere with the return value.
# Exposing stream 3 as a pipe to standard output of the script itself
exec 3>&1

# Setup some colors to use. These need to work in fairly limited shells, like the Ubuntu Docker container where there are only 8 colors.
# See if stdout is a terminal
    if [[ -t 1 ]] && command -v tput > /dev/null; then
        # see if it supports colors
        ncolors=$(tput colors)
        if [[ -n "$ncolors" ]] && [[ $ncolors -ge 8 ]]; then
            bold="$(tput bold           || echo)"
            normal="$(tput sgr0         || echo)"
            black="$(tput setaf 0       || echo)"
            red="$(tput setaf 1         || echo)"
            green="$(tput setaf 2       || echo)"
            yellow="$(tput setaf 3      || echo)"
            blue="$(tput setaf 4        || echo)"
            magenta="$(tput setaf 5     || echo)"
            cyan="$(tput setaf 6        || echo)"

            tan="$(tput setaf 3         || echo)"
            purple="$(tput setaf 171    || echo)"
            underline="$(tput sgr 0 1   || echo)"

            reset="$(tput sgr0          || echo)"
        fi
    fi

#
# Headers and  Logging
#
# A sample script
# e_header "I am a sample script"
# e_success "I am a success message"
# e_error "I am an error message"
# e_warning "I am a warning message"
# e_underline "I am underlined text"
# e_bold "I am bold text"
# e_note "I am a note"

function    e_header()
    {
        printf "\n${bold}${purple}==========  %s  ==========${reset}\n" "$@" 
    }
function    e_arrow()
    {
        printf "➜ $@\n"
    }
function    e_success()
    {
        printf "${green}✔ %s${reset}\n" "$@"
    }
function    e_error()
    {
        printf "${red}✖ %s${reset}\n" "$@"
    }
function    e_warning()
    {
        printf "${tan}➜ %s${reset}\n" "$@"
    }
function    e_underline()
    {
        printf "${underline}${bold}%s${reset}\n" "$@"
    }
function    e_bold()
    {
        printf "${bold}%s${reset}\n" "$@"
    }
function    e_note()
    {
        printf "${underline}${bold}${blue}Note:${reset}  ${blue}%s${reset}\n" "$@"
    }

####### Echo Warning #######
function    say_warning()
    {
        printf "%b\n" "${yellow:-} ➜ Warning: $@${normal:-}"
    }

####### Echo Error #######
function    say_err()
    {
        printf "%b\n" "${red:-} ✖ Error: $@${normal:-}" >&2
    }

####### Echo Normal #######
function    say()
    {
        # which may be used as return value
        printf "%b\n" "${cyan:-} ${normal:-} $@"
    }

####### utilities for processing text #######
####### echo with pause if not have content #######
# arg_input abc => echo abc
# arg_input => type content to input: _
arg_input() {
  local arg
  if [[ $# -eq 0 || -z "$1" ]]; then
    local func="type content to input"
    local -a args
    while (( ${#args[*]} == 0 )) ; do
      read -p "${func}? " args
    done
    arg="${args[0]}"
  else
    arg="$1"
  fi
  echo "$arg"
}

# url_encode [STRING] -- encode STRING for URLs
# url_encode          -- encode STDIN for URLs

# Note: must convert % first, otherwise the other entities will
# get double-converted.

url_encode() {
  arg_input "$@" |
  sed -Ee "\
           s/\%/%25/g  ;
           s/ /%20/g   ; s/\\\$/%24/g ;	s/\>/%3E/g  ;\
           s/#/%23/g   ;              ; s/\[/%5B/g  ;\
           s/'/%27/g   ; s/\&/%26/g   ; s/\]/%5D/g  ;\
           s/,/%2C/g   ; s/\(/%28/g   ; s/\^/%5E/g  ;\
           s/-/%2D/g   ; s/\)/%29/g   ; s/\`/%60/g  ;\
           s/=/%3D/g   ; s/\*/%2A/g   ; s/\{/%7B/g  ;\
           s/[\]/%5C/g ; s/\+/%2B/g   ; s/\|/%7C/g  ;\
           s/\!/%21/g  ; s/\//%2F/g   ; s/\}/%7D/g  ;\
           s/\"/%22/g  ; s/\</%3C/g   ; s/\~/%7E/g"
}

# url_decode STRING -- decode STRING for urls
# url_decode        -- decode STDIN for urls

url_decode() {
  arg_input "$@" |
  sed -e "\
           s/%20/ /g  ;  s/%29/)/g   ;   s/%5B/[/g    ;\
           s/%21/\!/g ;  s/%2A/*/g   ;   s/%5C/\\\\/g ;\
           s/%22/\"/g ;  s/%2B/+/g   ;   s/%5D/]/g    ;\
           s/%23/\#/g ;  s/%2C/,/g   ;   s/%5E/^/g    ;\
           s/%24/\$/g ;  s/%2D/-/g   ;   s/%60/\`/g   ;\
           s/%25/%/g  ;  s/%2F/\//g  ;   s/%7B/{/g    ;\
           s/%26/\&/g ;  s/%3C/</g   ;   s/%7C/|/g    ;\
           s/%27/'/g  ;  s/%3D/=/g   ;   s/%7D/}/g    ;\
           s/%28/(/g  ;  s/%3E/>/g   ;   s/%7E/~/g"
}

# html_encode STRING -- encode STRING for HTML presentation
# html_encode        -- encode STDIN  for HTML presentation
#
# converts '&' => &amp;  '>' => &gt;  '<' => &lt;

html_encode() {
  arg_input "$@" |
  sed -e "s/\&/\&amp;/g ; s/[<]/\&lt;/g  ; s/[>]/\&gt;/g"
}

# html_decode STRING  -- decode STRING from HTML presentation
# html_decode         -- decode STDIN from HTML presentation

html_decode() {
  arg_input "$@" |
  sed -Ee "s/\&lt;/</g ; s/\&gt;/>/g ; s/\&amp;/\&/g"
}
####### end utilities for processing text #######

####### machine has (check packages bin run) #######
# example: if machine_has "curl"; then .....
function    machine_has()
    {
        eval $invocation

        hash "${1}" > /dev/null 2>&1
        return $?
    }

####### Check Value #######
# String Comparisons
# +------------------+-----------------------------------------------+
# |   Conditions     |                    Description                |
# +------------------+-----------------------------------------------+
# | Str1 = Str2      | True if the strings are equal                 |                            
# | Str1 != Str2     | True if the strings are not equal             |
# | -n Str1          | True if the string is not null                | 
# | -z Str1          | True if the string is null                    |                             
# +------------------+-----------------------------------------------+

# Numeric Comparisons
# +------------------+-----------------------------------------------+
# |   Conditions     |                    Description                |
# +------------------+-----------------------------------------------+
# | expr1 -eq expr2  | True if the expressions are equal             |
# | expr1 -ne expr2  | True if the expressions are not equal         |
# | expr1 -gt expr2  | True if expr1 is greater than expr2           |
# | expr1 -ge expr2  | True if expr1 is greater than equal to expr2  |
# | expr1 -lt expr2  | True if expr1 is less than expr2              | 
# | expr1 -le expr2  | True if expr1 is less than or equal to expr2  |
# | !expr1           | Negates the result of the expression          |            
# +------------------+-----------------------------------------------+

# Arithmetic Comparisons
# -lt	<
# -gt	>
# -le	<=
# -ge	>=
# -eq	==
# -ne	!=

# String Comparisons
# =	equal
# !=	not equal
# <	less then
# >	greater then
# -n s1	string s1 is not empty
# -z s1	string s1 is empty

# check has value
function    has_value()
    {
        [[ -n ${1} ]]           && return $TRUE         || return $FALSE
    }
alias check_has_value=has_value

# check has empty
function    has_empty()
    {
        [[ -z ${1} ]]           && return $TRUE         || return $FALSE
    }
alias check_empty=has_empty
alias check_has_empty=has_empty

# check has equal
# example: has_equal 2 2
function    has_equal()
    {
        [[ ${1} == ${2} ]]      && return $TRUE         || return $FALSE
    }
alias check_has_equal=has_equal

# check has not equal
# example: has_equal 2 2
function    has_not_equal()
    {
        [[ ${1} != ${2} ]]      && return $TRUE         || return $FALSE
    }
alias check_has_not_equal=has_not_equal

# check has equal less
# example: has_equal_less 2 2
function    has_equal_less()
    {
        [[ ${1} -le ${2} ]]      && return $TRUE         || return $FALSE
    }
alias check_has_equal_less=has_equal_less

# check has equal greater
# example: has_equal_greater 2 2
function    has_equal_greater()
    {
        [[ ${1} -ge ${2} ]]      && return $TRUE         || return $FALSE
    }
alias check_has_equal_greater=has_equal_greater

# check has less
# example: has_less 2 2
function    has_less()
    {
        [[ ${1} -lt ${2} ]]       && return $TRUE         || return $FALSE
    }
alias check_has_less=has_less

# check has greater
# example: has_greater 2 2
function    has_greater()
    {
        [[ ${1} -gt ${2} ]]       && return $TRUE         || return $FALSE
    }
alias has_great=has_greater
alias check_has_great=has_greater
alias check_has_greater=has_greater

####### End check Value #######

# Check file newer
function    is_newer()
    {
        #
        # NAME
        #    is_newer - compare the dates of two files
        #
        # SYNOPSIS
        #    is_newer file1 file2
        #
        # DESCRIPTION
        #    This function will return true (0) if file1 has
        #    been modified more recently that file2; otherwise,
        #    it will return false (1).
        #    
        if [[ $# -ne 2 ]]; then
            echo "Usage: is_newer file1 file2" 1>&2
            return $FALSE
        fi

        if [ ! -e ${1} -o ! -e ${2} ]; then
            return $FALSE       # No
        fi

        if [[ -n "`find ${1} -newer ${2} -print`" ]]; then
            say "File or Folder: ${1} newer ${2}"
            return $TRUE       # Yes
        else
            say "File or Folder: ${2} newer ${1}"
            return $FALSE      # No
        fi
    }

# check numeric
function    is_numeric() 
    {
        #
        # NAME
        #    IsNumeric - determine if a string is numeric
        #
        # SYNOPSIS
        #    IsNumeric string
        #
        # DESCRIPTION
        #    This function will return true (0) if the string
        #    contains all numeric characters; otherwise, it
        #    will return false (1).
        #    
        if [[ $# -ne 1 ]]; then
            say_warning "This ${1} is not numeric"
            return $FALSE
        fi

        expr "${1}" + 1 >/dev/null 2>&1
        if [[ $? -ge 2 ]]; then
            say_warning "This ${1} is not numeric"
            return $FALSE
        fi

        say "This ${1} is numeric"
        return $TRUE
    }

# core command check value true/false
function    core_command_check_value()
    {
        object_check=$(echo ${object_check} | tr 'A-Z' 'a-z')
        say "checking value of ${object_check}.."
        if [[ $object_check == "true"       || $object_check == "y" || $object_check == "yes" || $object_check == "on" ]]; then
            say "value - $object_check - is true"
            return ${object_check_mode_true}
        elif [[ $object_check == "false"    || $object_check == "n" || $object_check == "no" || $object_check == "off" ]]; then
            say "value - $object_check - is false"
            return ${object_check_mode_false}
        elif [[ -z ${object_check} ]]; then
            say_warning "Value no set and current empty"
            return $FALSE
        else
            say_warning "value - $object_check - is unknow"
            return $FALSE
        fi
    }
# check value true
function    check_value_true()
    {
        object_check_mode_true=0
        object_check_mode_false=1
        object_check=${1}
            core_command_check_value                    && return $TRUE         || return $FALSE
    }
# check multi value true
function    check_value_trues()
    {
        object_check_mode_true=0
        object_check_mode_false=1
        for object_check in ${@}; do
            core_command_check_value                    && return $TRUE         || return $FALSE
        done
    }
# check multi value true just say not return
function    check_value_trues_say()
    {
        object_check_mode_true=0
        object_check_mode_false=1
        for object_check in ${@}; do
            core_command_check_value ${object_check}
        done
    }

# check value false
function    check_value_false()
    {
        object_check_mode_true=1
        object_check_mode_false=0
        object_check=${1}
            core_command_check_value ${object_check}    && return $TRUE         || return $FALSE
    }
# check multi value false
function    check_value_falses()
    {
        object_check_mode_true=1
        object_check_mode_false=0
        for object_check in ${@}; do
            core_command_check_value ${object_check}    && return $TRUE         || return $FALSE
        done
    }
# check multi value false just say not return
function    check_value_falses_say()
    {
        object_check_mode_true=1
        object_check_mode_false=0
        for object_check in ${@}; do
            core_command_check_value ${object_check}
        done
    }


    ####### Set download tool #######
    #################################

####### Download file #######
# download_with_curl /winrar.zip http://media.matmagoc.com/winrar.zip
function    download_with_curl()
    {
        FILE_TEMP="${1}"
        [[ -f "${FILE_TEMP}" ]] && rm -f "${FILE_TEMP}"
            echo "Downloading ..."
            curl -Ls "${2}" -o "${FILE_TEMP}"
    }
# download_with_wget /winrar.zip http://media.matmagoc.com/winrar.zip
function    download_with_wget()
    {
        FILE_TEMP="${1}"
        [[ -f $FILE_TEMP ]] && rm -f $FILE_TEMP
            say "Downloading ..."
            wget -O $FILE_TEMP --no-check-certificate "${2}"
    }
function    download_option()
    {
        say_warning "Check and set download tool..."
        if machine_has "curl"; then
            # download_tool for command download. use like this $download_tool
            export download_tool="curl -Ls"
            # DOWNLOAD_TOOL use when remove download tool package
            export DOWNLOAD_TOOL="curl"
            export download_save=download_with_curl
            say "use curl"
        elif machine_has "wget"; then
            export download_tool="wget"
            export DOWNLOAD_TOOL="wget"
            export download_save=download_with_wget
            say "use wget"
        else
            say_err "without download tool"
            sleep 3
            exit $FALSE
        fi
        if machine_has "curl" && machine_has "wget"; then export DOWNLOAD_TOOL="wget curl";fi
    }


    ####### Change path #######
    ###########################

# input - ${1}
function    to_lowercase()
    {
        #eval $invocation

        echo "$@" | tr '[:upper:]' '[:lower:]'
        return $TRUE
    }
function    to_uppercase()
    {
        #eval $invocation

        echo "$@" | tr '[:lower:]' '[:upper:]'
        return $TRUE
    }
## @fn trim()
## @ingroup string
## @brief Removes whitespace from both ends of a string.
function    trim()
    {
        echo "${1}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
    }

# args:
# input - ${1}
function    remove_trailing_slash()
    {
        #eval $invocation

        local input="${1:-}"
        echo "${input%/}"
        return $TRUE
    }

# args:
# input - ${1}
function    remove_beginning_slash()
    {
        #eval $invocation

        local input="${1:-}"
        echo "${input#/}"
        return $TRUE
    }

# args:
# root_path - ${1}
# child_path - ${2} - this parameter can be empty
function    combine_paths()
    {
        eval $invocation

        # TODO: Consider making it work with any number of paths. For now:
        if [[ ! -z "${3:-}" ]]; then
            say_err "combine_paths: Function takes two parameters."
            return $FALSE
        fi

        local root_path="$(remove_trailing_slash "${1}")"
        local child_path="$(remove_beginning_slash "${2:-}")"
        say "combine_paths: root_path=$root_path"
        say "combine_paths: child_path=$child_path"
        echo "$root_path/$child_path"
        return $TRUE
    }


    ####### Check and run from URL #######
    ######################################

####### Run from URL #######
function    run_url()
    {
        if machine_has "curl"; then
            # bash <(curl -s ${1})
            curl -s ${1} | bash
        elif machine_has "wget"; then
            wget --no-check-certificate -qO - ${1} | bash
        else
            say_err "without download tool"
            sleep 3
            exit $FALSE
        fi
    }

alias run_bash_url=run_url

    ####### Get Linux distribution #######
    ######################################

# os name. Export to $osname
function    get_osname()
    {
    eval $invocation

    local uname=$(uname)
    if [[ "$uname" = "Darwin" ]]; then
        say     "osx"
        return  $TRUE
    elif [[ "$uname" = "FreeBSD" ]]; then
        say     "freebsd"
        return  $TRUE
    elif [[ "$uname" = "Linux" ]]; then
        if [[ -e /etc/os-release ]] && [[ ! -e /etc/redhat-release ]]; then
            . /etc/os-release
            say     "$ID.$VERSION_ID"
            export  osname="$ID.$VERSION_ID"
            return  $TRUE
        elif [[ -e /etc/redhat-release ]]; then
            local redhatRelease=$(</etc/redhat-release)
            if [[ $redhatRelease == "CentOS release 6."*    || $redhatRelease == "CentOS Linux release 6."* || $redhatRelease == "Red Hat Enterprise Linux Server release 6."* ]]; then
                say     "rhel.6"
                export  osname="rhel.6"
                return  $TRUE
            elif [[ $redhatRelease == "CentOS release 7."*  || $redhatRelease == "CentOS Linux release 6."* || $redhatRelease == "Red Hat Enterprise Linux Server release 7."* ]]; then
                say     "rhel.7"
                export osname="rhel.7"
                return  $TRUE
            elif [[ $redhatRelease == "CentOS release 5."*  || $redhatRelease == "CentOS Linux release 5."* || $redhatRelease == "Red Hat Enterprise Linux Server release 5."* ]]; then
                say     "rhel.5"
                export osname="rhel.5"
                return  $TRUE
            else
                say "Red hat but cannot get release version"
                export osname="rhel"
                return  $TRUE
            fi

        elif [[ -e /etc/alpine-release ]]; then
                say     "alpine linux"
                export  osname="alpine.$(cat /etc/alpine-release)"
                return  $TRUE
        fi

            say     "Linux specific platform name and version could not be detected: UName = $uname"
            return  $FALSE
        fi

    say_err "OS name could not be detected: UName = $uname"
    return  $FALSE
    fi    
    }

# check debian need update
function    check_debian_need_update()
    {
        [[ ! -z /var/lib/apt/lists/ ]]  && return $TRUE     || return $FALSE
    }

# release name
[[ -f /etc/debian_version ]]            && export release=$(cat /etc/debian_version|grep -o [0-9]|head -n1)
# codename
[[ -f /etc/os-release ]]                && export codename="$(cat /etc/os-release |grep VERSION= |cut -f 2 -d \(|cut -f 1 -d \))"


    ####### Get architecture #######
    ################################

# simple machine architecture
    export arch=$(uname -i)
    # export arch=$(uname -m)

# dpkg architecture
function    check_dpkg()
    {
        if machine_has dpkg; then
            say "DPKG installed" 
            dpkg --print-architecture | awk -F- '{ print $NF }'
            return $TRUE
        else
            say_err "DPKG not found"
            return $FALSE
        fi
    }
function    dpkgArch()
    {
        if [[ ! -f /usr/bin/dpkg ]]; then
            # osname=$(get_osname)
            get_osname
                # redhat
                if [[ $osname == "rhel"* ]]; then 
                    [[ -f /usr/bin/dpkg ]]          && say "check dpkg done"      || yum install -y dpkg
                    check_dpkg
                # ubuntu
                elif [[ $osname == "ubuntu"* ]] || [[ $osname == "debian"* ]]; then
                    if check_debian_need_update     && [[ ! -f /usr/bin/dpkg ]]; then
                        apt-get install -y dpkg
                    elif ! check_debian_need_update && [[ ! -f /usr/bin/dpkg ]]; then
                        apt-get update              && apt-get install -y dpkg
                    fi
                    check_dpkg
                # alpine
                elif [[ $osname == "alpine"* ]]; then
                    [[ -f /usr/bin/dpkg ]]          && say "check dpkg done"      || apk add --no-cache dpkg
                    check_dpkg
                # opensuse
                elif [[ $osname == "opensuse"* ]]; then
                    [[ -f /usr/bin/dpkg ]]          && say "check dpkg done"      || zypper install -n dpkg
                    check_dpkg
                else
                    say_err "Cannot install dpkg to check Arch. Your OS not support"
                    return $FALSE
                fi
        fi
            dpkg --print-architecture | awk -F- '{ print $NF }'
            return $TRUE
    }

# machine architecture
function    get_machine_architecture()
    {
        eval $invocation

        if command -v uname > /dev/null; then
            CPUName=$(uname -m)
            case $CPUName in
            armv7l|arm)
                echo "arm"
                return $TRUE
                ;;
            aarch64|arm64)
                echo "arm64"
                return $TRUE
                ;;
            amd64|x64|x86_64)
                echo "x64"
                return $TRUE
                ;;
            x86)
                echo "x86"
                return $TRUE
                ;;
            esac
        fi

        # Always default to 'x64'
        # echo "x64"
        # return $TRUE
    }


    ####### User check, add, del #######
    ####################################

####### add a user #######
function    add_a_user()
    {
        USER=${1}
        PASSWORD=${2}
        shift; shift;
        # Having shifted twice, the rest is now comments ...
        COMMENTS=$@
        echo "Adding user $USER ..."
         get_osname
            if [[ $osname == "rhel"* ]]; then 
                useradd -c "$COMMENTS" $USER
            elif [[ $osname == "ubuntu"* || $osname == "debian"* ]]; then 
                useradd -c "$COMMENTS" $USER
            elif [[ $osname == "alpine"* ]]; then 
                adduser -c "$COMMENTS" $USER
            else
                say_err "Your OS not support"
                return $FALSE
            fi
        echo useradd -c "$COMMENTS" $USER
        echo passwd $USER $PASSWORD
        echo "Added user $USER ($COMMENTS) with pass $PASSWORD"
    }

##################################################################
# Purpose: Return true if script is executed by the root user
# Arguments: none
# Return: True or False
# Invoke the is_root()
# is_root && echo "You are logged in as root." || echo "You are not logged in as root."
##################################################################
function    is_root() 
    {
        [[ $(id -u) -eq 0 ]]            && return $TRUE                     || return $FALSE
    }
function    is_root_say() 
    {
        [[ $(id -u) -eq 0 ]]            && say "You are logged in as root." || say_warning "You are not logged in as root."
    }
function    require_root()
    {
        # check permission root
        say "Check root"
            if [[ "x$(id -u)" != 'x0' ]]; then
                echo 'Error: this script can only be executed by root'
                exit $FALSE
            fi
        say "You are logged in as root."
    }
##################################################################
# Purpose: Return true $user exits in /etc/passwd
# Arguments: ${1} (username) -> Username to check in /etc/passwd
# Return: True or False
# Find out if user account vivek exits or not
# is_user "vivek" && echo "Account found." || echo "Account not found."
##################################################################
function    is_user() 
    {
        local u="${1}"
        grep -q "^${u}" $PASSWD_FILE    && return $TRUE                     || return $FALSE
    }
function    is_user_say() 
    {
        for isuser in "${@}"; do
            is_user ${isuser}           && say "Account ${isuser} found."   || say_warning "Account ${isuser} not found."
        done
    }


    ####### Time Feature ###########
    ################################

## @fn now()
## @ingroup time
## @brief Displays the current timestamp.
## @return Current timestamp.
function    now()
    {
        date +%s
    }

## @fn elapsed()
## @ingroup time
## @brief Displays the time elapsed between the 'start' and 'stop'
## parameters.
## @param start Start timestamp.
## @param stop Stop timestamp.
## @return Time elapsed between the 'start' and 'stop' parameters.
function    elapsed()
    {
        START="${1}"
        STOP="${2}"

        ELAPSED=$(( STOP - START ))
        echo "Your elapsed time ${ELAPSED} seconds"
    }

## @fn start_watch()
## @ingroup time
## @brief Starts the watch.
function    start_watch()
    {
        __START_WATCH=$(now)
    }

## @fn stop_watch()
## @ingroup time
## @brief Stops the watch and displays the time elapsed.
## @retval 0 if succeed.
## @retval 1 if the watch has not been started.
## @return Time elapsed since the watch has been started.
function    stop_watch()
    {
        if [[ -n "$__START_WATCH" ]]; then
            STOP_WATCH=$(now)
            elapsed "$__START_WATCH" "$STOP_WATCH"
            return $TRUE
        else
            return $FALSE
        fi
    }


    ####### Function Feature #######
    ################################

####### Generate password #######
function    gen_passwd () 
    { 
        local l=${1};
        [[ "$l" == "" ]] && l=16;
        tr -dc A-Za-z0-9_ < /dev/urandom | head -c ${l} | xargs
    }

####### reload the nginx web server #######
function    reload_nginx()
    {
            /usr/local/nginx/sbin/nginx -s reload       && say 'nginx server reloaded.'         || say_err 'nginx server reload failed.'
    }

####### Copy file folder #######
function    copy_files_or_dirs_from_list()
    {
        eval $invocation

        local root_path="$(remove_trailing_slash "${1}")"
        local out_path="$(remove_trailing_slash "${2}")"
        local override="$3"
        local override_switch=$(if [[ "$override" = false ]]; then printf -- "-n"; fi)
        
        cat | uniq | while read -r file_path; do
            local path="$(remove_beginning_slash "${file_path#$root_path}")"
            local target="$out_path/$path"
            if [[ "$override" = true ]] || (! ([[ -d "$target" ]] || [[ -e "$target" ]])); then
                mkdir -p "$out_path/$(dirname "$path")"
                cp -R $override_switch "$root_path/$path" "$target"
            fi
        done
    }
    
#    dircopy - copy the contents of a directory
function    dircopy()
    {
        #
        # SYNOPSIS
        #    dircopy directory1 directory2
        #
        # DESCRIPTION
        #    This command will copy the contents of one directory
        #    to another.  The destination directory and any
        #    subdirectories will be created as needed.
        #
        # RETURN VALUE
        #    0    Successful completion
        #    1    Usage error
        #
        ############################################################
        CMDNAME=`basename $0`
        CURDIR=`pwd`                  # Current directory
        TARGET=                       # Destination directory

        if [[ $# -ne 2 ]]; then
            echo "Usage: $CMDNAME directory1 directory2" 1>&2
            return $FALSE
        fi

        if [[ ! -d "${1}" ]]; then
            echo "${1} is not a directory." 1>&2
            return $FALSE
        fi

        if [[ -f "${2}" ]]; then
            echo "${2} is not a directory." 1>&2
            return $FALSE
        fi

        if [[ ! -d "${2}" ]]; then
            mkdir -p "${2}"
        fi

        cd "${2}"
        TARGET=`pwd`
        cd $CURDIR

        cd "${1}"
        find . -depth -print          |
            cpio -pdmu $TARGET 2>&1  |
            grep -iv "blocks"
    }

# Defning return code check function
function    die()
    {
        if [[ ${1} -ne 0 ]]; then
            echo "Error: ${2}"
            exit ${1}
        fi
    } >&2 # function writes to stderr

# calculator
function    calc()
    {
        ((cipher=${1}))
        echo $cipher
        return $TRUE
    }

# read line
function    read_line()
    {
        n=1
        while read line; do
            # reading each line
            echo "Line $n : $line"
            n=$((n+1))
        done < ${1}
        return $TRUE
    }

# count line
function    count_line()
    {
        if [[ $# -lt 1 ]]; then
            echo "Usage: $0 file ..."
            return $FALSE
        fi

        echo "$0 counts the lines of code" 
            l=0
            n=0
            s=0

        for f in $*; do
            if [[ -O $f ]] # checks whether file owner is running the script
        then 
            l=`wc -l $f | sed 's/^\([0-9]*\).*$/\1/'`
            echo "$f: $l"
            n=$[ $n + 1 ]
            s=$[ $s + $l ]
        else
            continue
        fi
        done

        echo "$n files in total, with $s lines in total"
        return $TRUE
    }

#loading
function    loading()
    {
        for a in `seq 1 ${1}`; do
            echo "Loading: $a/${1}" 
            sleep 1;
        done

        echo "!!! Done !!!"
        return $TRUE
    }

# check Greater Lesser
function    check_greater()
    {
        if [[ ${1} -gt ${2} ]]; then
            echo "${1} > ${2}"
        elif [[ ${1} -lt ${2} ]]; then
            echo "${1} < ${2}"
        fi
        return $TRUE
    }

# print date and time
function    print_date()
    {
        echo "Today is `date +"%A %d %B %Y (%r)"`"
        return $TRUE
    }

####### Check file and folder #######
# check_file_block
function    check_file_block()
    {
        say "Checking file block: ${1}.."
        [[ -b ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_block()
    {
        for filefolder in "${@}"; do
            check_file_block ${filefolder}              && return $TRUE                             || return $FALSE
        done
    }
function    check_files_block_say()
    {
        for filefolder in "${@}"; do
            check_file_block ${filefolder}              && say "File: ${filefolder} is block."      || say_warning "File: ${filefolder} does not block."
        done
            return $TRUE
    }
# check_file_special_character
function    check_file_special_character()
    {
        say "Checking file special character: ${1}.."
        [[ -c ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_special_character()
    {
        for filefolder in "${@}"; do
            check_file_special_character ${filefolder}  && return $TRUE                             || return $FALSE
        done
    }
function    check_files_special_character_say()
    {
        for filefolder in "${@}"; do
            check_file_special_character ${filefolder}  && say "File: ${filefolder} is special character." || say_warning "File: ${filefolder} does not special character."
        done
            return $TRUE
    }
# check_folder
function    check_folder()
    {
        say "Checking folder: ${1}.."
        [[ -d ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_folders()
    {
        for filefolder in "${@}"; do
            check_folder ${filefolder}                  && return $TRUE                             || return $FALSE
        done
    }
function    check_folders_say()
    {
        for filefolder in "${@}"; do
            check_folder ${filefolder}                  && say "Folder: ${filefolder} exists."      || say_warning "Folder: ${filefolder} does not exists."
        done
            return $TRUE
    }
# check folder empty
function    check_folder_empty()
    {
        say "Checking folder: ${1}.."
        [[ -d ${1} ]]                                   && say "Folder: ${1} exists."               || return $FALSE
        [[ -z "`ls ${1}`" ]]                            && return $TRUE                             || return $FALSE
    }
function    check_folders_empty()
    {
        for filefolder in "${@}"; do
            check_folder_empty ${filefolder}            && return $TRUE                             || return $FALSE
        done
    }
function    check_folders_empty_say()
    {
        for filefolder in "${@}"; do
            check_folder_empty ${filefolder}            && say "Folder: ${filefolder} empty."       || say_warning "Folder: ${filefolder} does not empty."
        done
            return $TRUE
    }
# check_filefolder
function    check_filefolder()
    {
        say "Checking file, folder: ${1}.."
        [[ -e ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_filefolders()
    {
        for filefolder in "${@}"; do
            check_filefolder ${filefolder}              && return $TRUE                             || return $FALSE
        done
    }
function    check_filefolders_say()
    {
        for filefolder in "${@}"; do
            check_filefolder ${filefolder}          && say "File or Folder: ${filefolder} exists."  || say_warning "File or Folder: ${filefolder} does not exists."
        done
            return $TRUE
    }
# check_file
function    check_file()
    {
        say "Checking file: ${1}.."
        [[ -f ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files()
    {
        for filefolder in "${@}"; do
            check_file ${filefolder}                    && return $TRUE                             || return $FALSE
        done
    }
function    check_files_say()
    {
        for filefolder in "${@}"; do
            check_file ${filefolder}                    && say "File: ${filefolder} exists."        || say_warning "File: ${filefolder} does not exists."
        done
            return $TRUE
    }
# check_file_owned_groupid
function    check_file_owned_groupid()
    {
        say "Checking file owned groupid: ${1}.."
        [[ -G ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_owned_groupid()
    {
        for filefolder in "${@}"; do
            check_file_owned_groupid ${filefolder}      && return $TRUE                             || return $FALSE
        done
    }
function    check_files_owned_groupid_say()
    {
        for filefolder in "${@}"; do
            check_file_owned_groupid ${filefolder} && say "File: ${filefolder} have owned_groupid." || say_warning "File: ${filefolder} does not have owned_groupid."
        done
            return $TRUE
    }
# check_file_groupid
function    check_file_groupid()
    {
        say "Checking file groupid: ${1}.."
        [[ -g ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_groupid()
    {
        for filefolder in "${@}"; do
            check_file_groupid ${filefolder}            && return $TRUE                             || return $FALSE
        done
    }
function    check_files_groupid_say()
    {
        for filefolder in "${@}"; do
            check_file_groupid ${filefolder}            && say "File: ${filefolder} have groupid."  || say_warning "File: ${filefolder} does not have groupid."
        done
            return $TRUE
    }
# check_file_sticky
function    check_file_sticky()
    {
        say "Checking file sticky: ${1}.."
        [[ -k ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_sticky()
    {
        for filefolder in "${@}"; do
            check_file_sticky ${filefolder}             && return $TRUE                             || return $FALSE
        done
    }
function    check_files_sticky_say()
    {
        for filefolder in "${@}"; do
            check_file_sticky ${filefolder}             && say "File: ${filefolder} is sticky."     || say_warning "File: ${filefolder} does not sticky."
        done
            return $TRUE
    }
# check_file_symlink
function    check_file_symlink()
    {
        say "Checking file symlink: ${1}.."
        [[ -L ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_symlink()
    {
        for filefolder in "${@}"; do
            check_file_symlink ${filefolder}            && return $TRUE                             || return $FALSE
        done
    }
function    check_files_symlink_say()
    {
        for filefolder in "${@}"; do
            check_file_symlink ${filefolder}            && say "File: ${filefolder} is symlink."    || say_warning "File: ${filefolder} does not symlink."
        done
            return $TRUE
    }
# check_file_owned_userid
function    check_file_owned_userid()
    {
        say "Checking file owned userid: ${1}.."
        [[ -O ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_owned_userid()
    {
        for filefolder in "${@}"; do
            check_file_owned_userid ${filefolder}       && return $TRUE                             || return $FALSE
        done
    }
function    check_files_owned_userid_say()
    {
        for filefolder in "${@}"; do
            check_file_owned_userid ${filefolder} && say "File: ${filefolder} have owned_userid."   || say_warning "File: ${filefolder} does not have owned_userid."
        done
            return $TRUE
    }
# check_file_read
function    check_file_read()
    {
        say "Checking file read: ${1}.."
        [[ -r ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_read()
    {
        for filefolder in "${@}"; do
            check_file_read ${filefolder}               && return $TRUE                             || return $FALSE
        done
    }
function    check_files_read_say()
    {
        for filefolder in "${@}"; do
            check_file_read ${filefolder}               && say "File: ${filefolder} can read."      || say_warning "File: ${filefolder} cannot read."
        done
            return $TRUE
    }
# check_file_socket
function    check_file_socket()
    {
        say "Checking file socket: ${1}.."
        [[ -S ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_socket()
    {
        for filefolder in "${@}"; do
            check_file_socket ${filefolder}             && return $TRUE                             || return $FALSE
        done
    }
function    check_files_socket_say()
    {
        for filefolder in "${@}"; do
            check_file_socket ${filefolder}             && say "File: ${filefolder} is socket."     || say_warning "File: ${filefolder} does not socket."
        done
            return $TRUE
    }
# check_file_nonzero
function    check_file_nonzero()
    {
        say "Checking file nonzero: ${1}.."
        [[ -s ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_nonzero()
    {
        for filefolder in "${@}"; do
            check_file_nonzero ${filefolder}            && return $TRUE                             || return $FALSE
        done
    }
function    check_files_nonzero_say()
    {
        for filefolder in "${@}"; do
            check_file_nonzero ${filefolder}            && say "File: ${filefolder} nonzero."       || say_warning "File: ${filefolder} does not nonzero."
        done
            return $TRUE
    }
# check_file_userid
function    check_file_userid()
    {
        say "Checking file userid: ${1}.."
        [[ -u ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_userid()
    {
        for filefolder in "${@}"; do
            check_file_userid ${filefolder}             && return $TRUE                             || return $FALSE
        done
    }
function    check_files_userid_say()
    {
        for filefolder in "${@}"; do
            check_file_userid ${filefolder}             && say "File: ${filefolder} have userid."   || say_warning "File: ${filefolder} does not exists."
        done
            return $TRUE
    }
# check_file_write
function    check_file_write()
    {
        say "Checking file write: ${1}.."
        [[ -w ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_write()
    {
        for filefolder in "${@}"; do
            check_file_write ${filefolder}              && return $TRUE                             || return $FALSE
        done
    }
function    check_files_write_say()
    {
        for filefolder in "${@}"; do
            check_file_write ${filefolder}              && say "File: ${filefolder} can write."     || say_warning "File: ${filefolder} cannot write."
        done
            return $TRUE
    }
# check_file_run
function    check_file_run()
    {
        say "Checking file run: ${1}.."
        [[ -x ${1} ]]                                   && return $TRUE                             || return $FALSE
    }
function    check_files_run()
    {
        for filefolder in "${@}"; do
            check_file_run ${filefolder}                && return $TRUE                             || return $FALSE
        done
    }
function    check_files_run_say()
    {
        for filefolder in "${@}"; do
            check_file_run ${filefolder}                && say "File: ${filefolder} can run."       || say_warning "File: ${filefolder} cannot run."
        done
            return $TRUE
    }

# core command create object
function    core_command_create_object()
    {
        if ${command_check_object} ${object_create}; then
            say_warning "${object_create} exists"
        else
            say "Creating ${object_create}.."
            ${command_create_object} ${object_create}
            ${command_check_object} ${object_create}    && say "${object_create} created"           || return $FALSE
        fi
        return $TRUE
    }

# create dir
function    create_folder()
    {
        object_create="${1}"
        command_check_object=check_folder
        command_create_object="mkdir -p"
            core_command_create_object
    }
# create multi dir
function    create_folders()
    {
        command_check_object=check_folder
        command_create_object="mkdir -p"
        for object_create in "${@}"; do
            core_command_create_object
        done
    }

alias create_dir=create_folder
alias create_dirs=create_folders
alias make_dir=create_folder
alias make_dirs=create_folders
alias make_folder=create_folder
alias make_folders=create_folders

# create file
function    create_file()
    {
        object_create="${1}"
        command_check_object=check_file
        command_create_object="touch"
            core_command_create_object
    }
# create multi file
function    create_files()
    {
        command_check_object=check_file
        command_create_object="touch"
        for object_create in "${@}"; do
            core_command_create_object
        done
    }

alias make_file=create_file
alias make_files=create_files

# create file. use like this: create_symlink /source /destination
function    create_symlink()
    {
        object_create="${1} ${2}"
        command_check_object=check_filefolders
        command_create_object="ln -sf"
            core_command_create_object
    }

alias make_symlink=create_symlink

# core command remove object
function    core_command_remove_object()
    {
        if ${command_check_object} ${object_remove}; then
            say "Removing ${object_remove}.."
            rm -rf ${object_remove}
            ${command_check_object} ${object_remove}      && return $FALSE                          || say "${object_remove} removed"
        else
            say_warning "${object_remove} not exists"
        fi
        return $TRUE
    }

# remove folder
function    remove_folder()
    {
        object_remove="${@}"
        command_check_object=check_folder
            core_command_remove_object
    }
# remove multi folder
function    remove_folders()
    {
        command_check_object=check_folder
        for object_remove in "${@}"; do
            core_command_remove_object
        done
    }

alias del_dir=remove_folder
alias del_dirs=remove_folders
alias delete_dir=remove_folder
alias delete_dirs=remove_folders
alias remove_dir=remove_folder
alias remove_dirs=remove_folders
alias del_folder=remove_folder
alias delele_folder=remove_folder
alias del_folders=remove_folders
alias delele_folders=remove_folders

# remove file
function    remove_file()
    {
        object_remove="${@}"
        command_check_object=check_file
            core_command_remove_object
    }
# remove multi file
function    remove_files()
    {
        command_check_object=check_file
        for object_remove in ${@}; do
            core_command_remove_object
        done
    }

alias del_file=remove_file
alias delele_file=remove_file
alias del_files=remove_files
alias delele_files=remove_files

# remove file symlink
function    remove_symlink()
    {
        object_remove="${@}"
        command_check_object=check_file_symlink
            core_command_remove_object
    }
# remove multi file symlink
function    remove_symlinks()
    {
        command_check_object=check_file_symlink
        for object_remove in ${@}; do
            core_command_remove_object
        done
    }

# remove file and folder. Can use this command to remove abc*
function    remove_filefolder()
    {
        say "Removing ${@}..."
        rm -rf ${@}
    }
# remove multi file and folder.Cannot use this command to remove abc*
function    remove_filefolders()
    {
        command_check_object=check_filefolder
        for object_remove in ${@}; do
            core_command_remove_object
        done
    }

alias remove_filefolders=remove_filefolders
alias del_filefolder=remove_filefolder
alias delele_filefolder=remove_filefolder
alias del_filefolders=remove_filefolders
alias delele_filefolders=remove_filefolders
alias del_filesfolders=remove_filefolders
alias delele_filesfolders=remove_filesfolders

# core command set mod
function    core_command_set_object()
    {
        $command_check_object ${object_set}               && $command_set_object ${object_mode} ${object_set} || return $FALSE
        say "set mode to ${object_set} "                  && return $TRUE
    }

# set file owner
function    set_file_owner()
    {
        command_check_object=check_file
        command_set_object="chown"
        command_set_object_say=owner
        object_mode=${1}
        object_set="${2}"
            core_command_set_object
    }

# set multi file owner
function    set_files_owner()
    {
        command_check_object=check_files
        command_set_object="chown"
        command_set_object_say=owner
        object_mode=${1}
        object_set="${@:2}"
            core_command_set_object
    }
# set folder owner
function    set_folder_owner()
    {
        command_check_object=check_folder
        command_set_object="chown -R"
        command_set_object_say=owner
        object_mode=${1}
        object_set="${2}"
            core_command_set_object
    }
# set multi folder owner
function    set_folders_owner()
    {
        command_check_object=check_folders
        command_set_object="chown -R"
        command_set_object_say=owner
        object_mode=${1}
        object_set="${@:2}"
            core_command_set_object
    }

# set filefolder owner
function    set_filefolder_owner()
    {
        command_check_object=check_filefolder
        command_set_object="chown -R"
        command_set_object_say=owner
        object_mode=${1}
        object_set="${2}"
            core_command_set_object
    }
# set multi filefolder owner
function    set_filefolders_owner()
    {
        command_check_object=check_filefolders
        command_set_object="chown -R"
        command_set_object_say=owner
        object_mode=${1}
        object_set="${@:2}"
            core_command_set_object
    }

# set file mod
function    set_file_mod()
    {
        command_check_object=check_file
        command_set_object="chmod"
        command_set_object_say=mod
        object_mode=${1}
        object_set="${2}"
            core_command_set_object
    }
# set multi file mod
function    set_files_mod()
    {
        command_check_object=check_files
        command_set_object="chmod"
        command_set_object_say=mod
        object_mode=${1}
        object_set="${@:2}"
            core_command_set_object
    }

# set folder mod
function    set_folder_mod()
    {
        command_check_object=check_folder
        command_set_object="chmod -R"
        command_set_object_say=mod
        object_mode=${1}
        object_set="${2}"
            core_command_set_object
    }
# set folder mod
function    set_folders_mod()
    {
        command_check_object=check_folders
        command_set_object="chmod -R"
        command_set_object_say=mod
        object_mode=${1}
        object_set="${@:2}"
            core_command_set_object
    }

# set filefolder mod
function    set_filefolder_mod()
    {
        command_check_object=check_filefolder
        command_set_object="chmod -R"
        command_set_object_say=mod
        object_mode=${1}
        object_set="${2}"
            core_command_set_object
    }
# set multi filefolder mod
function    set_filefolders_mod()
    {
        command_check_object=check_filefolders
        command_set_object="chmod -R"
        command_set_object_say=mod
        object_mode=${1}
        object_set="${@:2}"
            core_command_set_object
    }

# rsync folder
# example backup from /media/server to /backup/server
# command: rsync_folder /media/server /backup/server
function    rsync_folder()
    {
        say "Checking folder.."
        check_folder ${1}                     && say "check ${1} done"          || return $FALSE
        check_folder ${2}                     && say "check ${2} done"          || return $FALSE
        say "Begin rsync.."
        machine_has rsync                                                       || return $FALSE
        rsync -arvpz --delete --numeric-ids ${1} ${2}
        say "Rsync completed"
        return $TRUE
    }

# rsync os root
# example backup from / to /backup/server
# command: rsync_os / /backup/server
function   rsync_os()
    {
        say "Checking folder.."
        check_folder ${1}                     && say "check ${1} done"          || return $FALSE
        check_folder ${2}                     && say "check ${2} done"          || return $FALSE
        say "Begin rsync.."
        machine_has rsync                                                       || return $FALSE
        rsync -arvpz --delete --numeric-ids --exclude dev --exclude proc --exclude tmp --exclude media ${1} ${2}
        say "Rsync completed"
        return $TRUE
    }

# rsync folder from ssh
# use example - rsync from 192.168.0.100/ to /backup_server
# command for folder normal: rsync_folder_from_ssh root@192.168.0.100 22 /opt/app /backup_server
# command for os root: rsync_os_from_ssh root@192.168.0.100 22 / /backup_server
function    rsync_folder_from_ssh()
    {
        say "Checking folder.."
        check_folder ${4}                   && say "check ${4} done"            || return $FALSE
        say "Begin rsync.."
        is_numeric ${2}                     && say "check ${2} done"            || return $FALSE
        machine_has rsync                   && say "check rsync done"           || return $FALSE
        rsync -arvpz --delete --numeric-ids -e 'ssh -p ${2}' "${1}:${3}" ${4}
        say "Rsync completed"
        return $TRUE
    }

# rsync os root folder from ssh
function    rsync_os_from_ssh()
    {
        say "Checking folder.."
        check_folder ${4}                   && say "check ${4} done"            || return $FALSE
        say "Begin rsync.."
        is_numeric ${2}                     && say "check ${2} done"            || return $FALSE
        machine_has rsync                   && say "check rsync done"           || return $FALSE
        rsync -arvpz --delete --numeric-ids --exclude dev --exclude proc --exclude tmp --exclude media -e 'ssh -p ${2}' "${1}:${3}" ${4}
        say "Rsync completed"
        return $TRUE
    }

# rsync folder to ssh
# use example - rsync from /backup_server to 192.168.0.100/
# command for folder normal: rsync_folder_from_ssh /backup_server root@192.168.0.100 22 /opt/app
# command for os root: rsync_os_from_ssh /backup_server root@192.168.0.100 22 / 
function    rsync_folder_to_ssh()
    {
        say "Checking folder.."
        check_folder ${1}                   && say "check ${1} done"            || return $FALSE
        say "Begin rsync.."
        is_numeric ${2}                     && say "check ${2} done"            || return $FALSE
        machine_has ssh                     && say "check ssh done"             || return $FALSE
        machine_has rsync                   && say "check rsync done"           || return $FALSE
        rsync -arvpz --delete --numeric-ids -e "ssh -p ${3}" ${1} "${2}:${4}"
        say "Rsync completed"
        return $TRUE
    }

# rsync os root folder to ssh
function    rsync_os_to_ssh()
    {
        say "Checking folder.."
        check_folder ${1}                   && say "check ${1} done"            || return $FALSE
        say "Begin rsync.."
        is_numeric ${2}                     && say "check ${2} done"            || return $FALSE
        machine_has ssh                     && say "check ssh done"             || return $FALSE
        machine_has rsync                   && say "check rsync done"           || return $FALSE
        rsync -arvpz --delete --numeric-ids  -e "ssh -p ${3}" ${1} "${2}:${4}"
        say "Rsync completed"
        return $TRUE
    }

# tar folder
# example use: tar folder /abc to /backup.tar.gz
# command: tar_folder /backup.tar.gz /abc
# $1 is destination tar file, $2 folder need tar, $3 is extra option
function    tar_folder()
    {
        say "Checking folder.."
        check_folder ${2}                   && say "check ${2} done"            || return $FALSE
        check_file ${1}                     && return $FALSE                    || say "check ${1} done"
        say "Begin tar compress.."
        machine_has tar     && tar -cvpzf ${3} ${1} --exclude=${1} ${2}         || return $FALSE
        say "Tar completed"
        return $TRUE
    }
# tar file
function    tar_file()
    {
        say "Checking file.."
        check_file ${2}                     && say "check ${2} done"            || return $FALSE
        check_file ${1}                     && return $FALSE                    || say "check ${1} done"
        say "Begin tar compress.."
        machine_has tar     && tar -cvpzf ${3} ${1} --exclude=${1} ${2}         || return $FALSE
        say "Tar completed"
        return $TRUE
    }
# tar file folder
function    tar_filefolder()
    {
        say "Checking file folder.."
        check_folder ${2}                   && say "check ${2} done"            || return $FALSE
        check_folder ${1}                   && return $FALSE                    || say "check ${1} done"
        say "Begin tar compress.."
        machine_has tar     && tar -cvpzf ${3} ${1} --exclude=${1} ${2}         || return $FALSE
        say "Tar completed"
        return $TRUE
    }

# tar folder over ssh
# example backup /abc to backupserver with path /backup/abc.tar.gz
# use: tar_folder_ssh /abc root@backupserver /backup/abc.tar.gz
#
function    tar_folder_ssh()
    {
        say "Begin Tar compress, checking folder.."
        check_folder ${1}                   && say "check ${1} done"            || return $FALSE
        say "Begin tar compress.."
        machine_has tar                     && say "check tar done"             || return $FALSE
        machine_has ssh                     && say "check ssh done"             || return $FALSE
        tar -cvpzf - ${1} | ssh ${2} "cat > ${3}"
        say "Tar completed"
        return $TRUE
    }
# tar file over ssh
function    tar_file_ssh()
    {
        say "Checking file.."
        check_file ${1}                     && say "check ${1} done"            || return $FALSE
        say "Begin tar compress.."
        machine_has tar                     && say "check tar done"             || return $FALSE
        machine_has ssh                     && say "check ssh done"             || return $FALSE
        tar -cvpzf - ${1} | ssh ${2} "cat > ${3}"
        say "Tar completed"
        return $TRUE
    }
# tar file folder over ssh
function    tar_filefolder_ssh()
    {
        say "Checking file folder.."
        check_filefolder ${1}               && say "check ${1} done"            || return $FALSE
        say "Begin tar compress.."
        machine_has tar                     && say "check tar done"             || return $FALSE
        machine_has ssh                     && say "check ssh done"             || return $FALSE
        tar -cvpzf - ${1} | ssh ${2} "cat > ${3}"
        say "Tar completed"
        return $TRUE
    }

# tar extract
# example extract to /abc from /backup/abc.tar.gz
# use: tar_extract /backup/abc.tar.gz /abc
# $1 is source tar file, $2 folder destination, $3 is extra option
function    tar_extract()
    {
        say "Checking file folder.."
        check_file ${1}                     && say "check ${1} done"            || return $FALSE
        say "Begin tar extracting.."
        check_empty ${2}    && ${2}="."                                         || say "check ${2} done"
        machine_has tar     && tar -xvpzf ${1} -C ${2} --numeric-owner ${@:3}   || return $FALSE
        say "Tar completed"
        return $TRUE
    }

alias tar_x=tar_extract

# tar extract over ssh
# example extract to /abc from backupserver with path /backup/abc.tar.gz
# use: tar_extract_ssh root@backupserver /backup/abc.tar.gz /abc
#
function    tar_extract_ssh()
    {
        say "Begin tar extracting.."
        machine_has ssh                     && say "check ssh done"             || return $FALSE
        ssh ${1} "cat > ${2}"               | tar -xvpzf - ${3}
        say "Tar completed"
        return $TRUE
    }

alias tar_extract_from_ssh=tar_extract_ssh
alias tar_x_from_ssh=tar_extract_ssh
alias tar_x_ssh=tar_extract_ssh

# unzip extract
# example extract to /abc from /backup/abc.zip
# use: unzip_extract /backup/abc.zip /abc
# $1 is source zip file, $2 folder destination, $3 is extra option
function    unzip_extract()
    {
        say "Checking file folder.."
        check_file ${1}                     && say "check ${1} done"            || return $FALSE
        say "Begin unzip extracting.."
        check_empty ${2}                    && ${2}="."                         || say "check ${2} done"
        machine_has unzip                   && unzip - ${1} -d ${2} ${@:3}      || return $FALSE
        say "Unzip completed"
        return $TRUE
    }

alias unzip_x=unzip_extract

# unzip extract over ssh
# example extract to /abc from backupserver with path /backup/abc.zip
#
# use: unzip_extract_ssh root@backupserver /backup/abc.zip /abc
#
function    unzip_extract_ssh()
    {
        say "Begin unzip extracting.."
        machine_has ssh                     && say "check ssh done"             || return $FALSE
        ssh ${1} "cat > ${2}"               | unzip - ${3}
        say "Unzip completed"
        return $TRUE
    }

alias unzip_extract_from_ssh=unzip_extract_ssh
alias unzip_x_from_ssh=unzip_extract_ssh
alias unzip_x_ssh=unzip_extract_ssh

# scp folder
# example copy from /abc to 192.168.0.12:/home/abc
# scp_folder root@192.168.0.12:/home/abc /abc
function    scp_folder()
    {
        say "Begin scp copying.."
        machine_has scp                     && say "check scp done"             || return $FALSE
        scp -pr ${1} ${2}
        say "scp completed"
        return $TRUE
    }

# scp to ssh
# example copy from /abc to 192.168.0.12:/home/abc
# scp_to_ssh /abc root@192.168.0.12 /home/abc
function    scp_to_ssh()
    {
        say "Begin scp copying.."
        machine_has scp                     && say "check scp done"             || return $FALSE
        scp -pr ${1} ${2}:${3}
        say "scp completed"
        return $TRUE
    }

# scp from ssh
# example copy from /abc to 192.168.0.12:/home/abc
# scp_from_ssh root@192.168.0.12 /home/abc /abc
function    scp_from_ssh()
    {
        say "Begin scp copying.."
        machine_has scp                     && say "check scp done"             || return $FALSE
        scp -pr ${1}:${2} ${3}
        say "scp completed"
        return $TRUE
    }

# tar copy compress ssh
# copy over ssh use tar with compress package, maybe use more cpu
#
# example copy from /abc from backupserver to /home/abc
#
# use: tar_copy_compress_ssh root@backupserver /abc /home/abc
#
function    tar_copy_compress_ssh()
    {
        machine_has tar                     && say "check tar done"             || return $FALSE
        machine_has ssh                     && say "check ssh done"             || return $FALSE
        ssh ${1} "tar czf - ${2}"           | tar xvzf - -C ${3}
    }

# tar copy ssh
# copy over ssh use tar without compress package, maybe faster
#
# example copy from /abc from backupserver to /home/abc
#
# use: tar_copy_ssh root@backupserver /abc /home/abc
#
function    tar_copy_ssh()
    {
        machine_has tar                     && say "check tar done"             || return $FALSE
        machine_has ssh                     && say "check ssh done"             || return $FALSE
        ssh ${1} "tar c - ${2}"             | tar xvf - -C ${3}
    }

#    DirCmp - compare the files in two directories
function    dircmp()
    {
        # SYNOPSIS
        #    DirCmp [-v] [dir1] dir2
        #
        # DESCRIPTION
        #    This command compares the files in two directories and
        #    lists the files that are not the same.  There will be
        #    three separate lists for: 
        #
        #    1. Files not in the first directory, but in the second
        #    2. Files not in the second directory, but in the first
        #    3. Files in both directories, but not the same
        #
        #    -v   Verbose option.  This option prints the lines that
        #         are different rather than just the name of the
        #         file when the file is in both directories, but the
        #         files are not the same.
        #
        # RETURN VALUE
        #    0    The directories are the same
        #    1    Usage error or abnormal termination
        #    2    The directories are not the same
        #
        ############################################################
            CMDNAME=`basename $0`
            USAGE="Usage: $CMDNAME [-v] [dir1] dir2"

            CURDIR=`pwd`                  # Current directory
            DIR1=                         # Source directory
            DIR2=                         # Target directory
            DIR1_FILES=/tmp/files1.$$     # Files in dir1
            DIR2_FILES=/tmp/files2.$$     # Files in dir2
            ALL_FILES=/tmp/allfiles.$$    # Files in dir1 or dir2
            COMMON_FILES=/tmp/comfiles.$$ # Files in dir1 and dir2
            TMP=/tmp/tmp.$$               # Temporary file
            FOUND=FALSE                   # Differences found?
            FIRST=
            VERBOSE=FALSE

        # trap 'rm -f /tmp/*.$$; exit 1' 1 2 3 15

        #
        # Parse the command options.
        #
        while :
        do
            case ${1} in
                -v)  VERBOSE=TRUE
                    shift
                    ;;
                --)  shift
                    break
                    ;;
                -*)  echo "$USAGE" 1>&2
                    return $FALSE
                    ;;
                *)   break
                    ;;
            esac
        done

        #
        # Get command line arguments.
        #
        if [[ $# -eq 1 ]]; then
            DIR1="."
            DIR2="${1}"
        elif [[ $# -eq 2 ]]; then
            DIR1="${1}"
            DIR2="${2}"
        else
            echo "$USAGE" 1>&2
            return $FALSE
        fi

        #
        # Check the directories.
        #
        if [[ ! -d $DIR1 ]]; then
            say_err "$DIR1 is not a directory." 1>&2
            return 2
        fi

        if [[ ! -d $DIR2 ]]; then
            say_err "$DIR2 is not a directory." 1>&2
            return 2
        fi

        #
        # Find the files to compare.
        #
        cd $DIR1
        find . \( -type f -o -type l \) -print | sort >$DIR1_FILES
        cd $CURDIR

        cd $DIR2
        find . \( -type f -o -type l \) -print | sort >$DIR2_FILES
        cd $CURDIR

        #
        # Build a list of all files.
        #
        cat $DIR1_FILES $DIR2_FILES | sort | uniq    >$ALL_FILES
        cat $DIR1_FILES $DIR2_FILES | sort | uniq -d >$COMMON_FILES

        #
        # Print the files that are in dir2, but not in dir1.
        #
        cat $DIR1_FILES $ALL_FILES | sort | uniq -u >$TMP
        if [[ -s $TMP ]]; then
            FOUND=TRUE
            say ""
            say_warning "Files missing from $DIR1:"
            for f in `cat $TMP`
            do
                f=`expr $f : '..\(.*\)'`
                say "	$f"
            done
        fi

        #
        # Print the files that are in dir1, but not in dir2.
        #
        cat $DIR2_FILES $ALL_FILES | sort | uniq -u >$TMP
        if [[ -s $TMP ]]; then
            FOUND=TRUE
            say ""
            say_warning "Files missing from $DIR2:"
            for f in `cat $TMP`
            do
                f=`expr $f : '..\(.*\)'`
                echo "	$f"
            done
        fi

        #
        # Print the files that are in dir1 and dir2, but are not
        # the same.
        #
        FIRST=TRUE
        for f in `cat $COMMON_FILES`
        do
            cmp -s $DIR1/$f $DIR2/$f
            if [[ $? -ne 0 ]]; then
                FOUND=TRUE
                f=`expr $f : '..\(.*\)'`
                if [[ "$FIRST" = "TRUE" ]]; then
                    FIRST=FALSE
                    say ""
                    say_warning "Files that are not the same:"
                fi

                if [[ "$VERBOSE" = "TRUE" ]]; then
                    say ""
                    say "File: $f"
                    diff $DIR1/$f $DIR2/$f
                else
                    echo "	$f"
                fi
            fi
        done

        rm -f /tmp/*.$$
        if [[ $FOUND = TRUE ]]; then
            return 2
        else
            say "The directories are the same."
            return $TRUE
        fi
    }

alias DirCmp=dircmp

#    findfile - recursively search for a file
function    findfile()
    {
        # SYNOPSIS
        #    findfile file [directory ...]
        #
        # DESCRIPTION
        #    This command searches the directories and their
        #    subdirectories for the file.  If no directories are
        #    listed on the command line, the current directory is
        #    searched.  If the file is found, the path name of the
        #    file is printed.
        #
        #    If the file name contains wildcard characters, it must
        #    be quoted so that the wildcard characters can be
        #    processed inside this shell script rather than being
        #    expanded into file names on the command line.
        #
        # RETURN VALUE
        #    0    Successful completion
        #    1    Usage error
        #
        ############################################################
        CMDNAME=`basename $0`
        if [[ $# -eq 0 ]]; then
            echo "Usage: $CMDNAME file [directory ...]" 1>&2
            return $FALSE
        fi

        NAME=${1}
        shift

        find "${@:-.}" -name "$NAME" -print
    }

alias find_file=findfile
alias find_folder=findfile
alias search_file=findfile
alias search_folder=findfile


# Group: String
# ----------------------------------------------------#

## @fn str_replace()
## @ingroup string
## @brief Replaces some text in a string.
## @param origin Content to be matched.
## @param destination New content that replaces the matched content.
## @param data Data to operate on.
## @return The new string after having replaced the matched
## content with the new one.
function    str_replace() 
    {
        local ORIG="${1}"
        local DEST="${2}"
        local DATA="$3"

        echo "${DATA//$ORIG/$DEST}"
    }

## @fn str_replace_in_file()
## @ingroup string
## @brief Replaces some text in a file.
## @param origin Content to be matched.
## @param destination New content that replaces the matched content.
## @param file File to operate on.
## @retval 0 if the original content has been replaced.
## @retval 1 if an error occurred.
function    str_replace_in_file()
    {
        [[ $# -lt 3 ]] && return $FALSE

        local ORIG="${1}"
        local DEST="${2}"

        for FILE in "${@:3:$#}"; do
            check_file "$FILE" || return $FALSE

            printf ",s/$ORIG/$DEST/g\nw\nQ" | ed -s "$FILE" > /dev/null 2>&1 || return "$?"
        done

        return $TRUE
    }

#    findstr - recursively search for a string
function    findstr()
    {
        # SYNOPSIS
        #    findstr [-iv] string [filename]
        #
        # DESCRIPTION
        #    This command searches the files in the current
        #    directory and its subdirectories for the string.  The
        #    name of each file that contains the string is listed.
        #
        #    The string may be a simple string or it may be any
        #    regular expression accepted by the grep command.  If
        #    the string contains whitespace or any other
        #    metacharacter, it must be quoted.
        #
        #    The search can be restricted to files with a particular
        #    name by specifying the file name parameter.  This
        #    parameter may contain wildcard characters to restrict
        #    the search to file names that match a pattern, but the
        #    file name must be quoted so that the wildcard
        #    characters can be processed inside this command file
        #    rather than being expanded into file names on the
        #    command line.
        #
        #    -i   Ignore the case of the string.
        #
        #    -v   Verbose; list the lines that contain the string.
        #         Without this option, only the names of the files
        #         containing the string will be printed.
        #
        # RETURN VALUE
        #    0    Successful completion
        #    1    Usage error
        #
        ############################################################
        CMDNAME=`basename $0`
        USAGE="Usage: $CMDNAME [-iv] string [filename]"
        STRING=                  # String to search for
        FILENAME=                # Name of the files to check
        I=                       # Option for grep; Ignore case
        L=-l                     # Option for grep; List names only

        #
        # Parse command options.
        #
        if [[ "$OPTIND" = 1 ]]; then
            while getopts iv OPT
            do
                case $OPT in
                    i)   I=-i      # Ignore case
                            ;;
                    v)   L=        # Verbose
                            ;;
                    \?)  echo "$USAGE" 1>&2
                            return $FALSE
                            ;;
                esac
            done
            shift `expr $OPTIND - 1`
        else
            USAGE="Usage: $CMDNAME [-i][-v] string [filename]"
            while :
            do
                case ${1} in
                    -i)  I=-i      # Ignore case
                            shift
                            ;;
                    -v)  L=        # Verbose
                            shift
                            ;;
                    --)  shift
                            break
                            ;;
                    -*)  echo "$USAGE" 1>&2
                            return $FALSE
                            ;;
                    *)   break
                            ;;
                esac
            done
        fi

        #
        # Make sure the number of parameters is reasonable.
        #
        if [ $# -lt 1 -o $# -gt 2 ]; then
            echo "$USAGE" 1>&2
            return $FALSE
        fi

        STRING=${1}
        FILENAME=${2:-"*"}

        find . \( -type f -o -type l \) -name "$FILENAME" -print |
            xargs -e grep $I $L -- "$STRING" /dev/null

        return $TRUE
    }
alias findstring=findstr
alias find_string=findstr
alias search_string=findstr

function    hex2decimal()
    {
        NUM=`echo ${1}    | tr '[a-f]' '[A-F]'`
        echo 16i $NUM p | dc
    }

# check process
function    check_process()
    {
        grep -x ${1} >/dev/null                && return $TRUE                  || return $FALSE
    }
function    check_process_say()
    {
        for process in "${@}"; do
            grep -x $process >/dev/null        && say "Process found"           || say_warning "Process not found"
        done
        return $TRUE
    }


    ####### Function Install #######
    ################################

# check epel
function    check_epel()
    {
        [[ -f /etc/yum.repos.d/epel.repo ]]     && return $TRUE                 || return $FALSE
    }
function    check_epel_say()
    {
        [[ -f /etc/yum.repos.d/epel.repo ]]     && say "EREL REPO installed"    || say_warning "EREL REPO not found"
    }
# install epel repo
function    install_epel()
    {
    if ! check_epel; then
        say "EPEL Repo not found"
        # osname=$(get_osname)
        get_osname
        is_root && sudo_command="" || sudo_command="sudo "
            if [[ $osname == "rhel.6" ]]; then 
                ${sudo_command}yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm
            elif [[ $osname == "rhel.7" ]]; then 
                ${sudo_command}yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
            elif [[ $osname == "rhel.5" ]]; then 
                ${sudo_command}yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-5.noarch.rpm
            else
                say_err "Cannot install EPEL. Your OS not support"
                return $FALSE
            fi
            check_epel          && say "EREL REPO installed"        || say_err "EREL REPO not found"
            check_epel          && return $TRUE                     || return $FALSE
    else
        say "EPEL Repo installed"
        return $TRUE
    fi
    }
# remove epel repo
function    remove_epel()
    {
        is_root && sudo_command="" || sudo_command="sudo "
        if ! check_epel; then
            say "EPEL Repo not found"
            return $TRUE
        else
            say "EPEL Repo installed"
            ${sudo_command}yum remove epel* -y
            check_epel          && say "EREL REPO removed"          || say_err "EREL REPO found and Cannot removed"
            check_epel          && return $TRUE                     || return $FALSE
        fi
    }

# update_os
function    update_os()
    {
        # osname=$(get_osname)
        get_osname
        say "install ${software}.."
        is_root && sudo_command="" || sudo_command="sudo "
            if [[ $osname == "ubuntu"* || $osname == "debian"* ]]; then
                check_debian_need_update && ${sudo_command}apt-get update || say "no need update repo"
                ${sudo_command}apt-get dist-upgrade -y
            elif [[ $osname == "rhel"* ]]; then
                ${sudo_command}yum update -y
            elif [[ $osname == "alpine"* ]]; then
                ${sudo_command}apk --no-cache upgrade
            elif [[ $osname == "opensuse"* ]]; then
                ${sudo_command}zypper -n update
            else
                say_err "Cannot Upgrade. OS not support."
                return $FALSE
            fi
        return $TRUE
    }

alias upgrade_os=update_os

# core command install. Core command for install packages
function    core_command_install()
    {
        # osname=$(get_osname)
        get_osname
        say "install ${software}.."
        is_root && sudo_command="" || sudo_command="sudo "
            if [[ $osname == "ubuntu"* || $osname == "debian"* ]]; then
                ${sudo_command}check_debian_need_update && ${sudo_command}apt-get update        || say "no need update repo"
                if [[ $software == *".deb" ]]; then
                    ${sudo_command}dpkg -i ${software}  && say "install ${software} completed"  || ${sudo_command}apt-get install -f -y
                elif [[ $software == *".rpm" ]]; then
                    say "This package for redhat/centos, cannot install on this server"         && return $FALSE
                else
                    ${sudo_command}apt-get install -y --no-install-recommends ${software}
                fi
            elif [[ $osname == "rhel"* ]]; then
                if [[ $software == *".rpm" ]]; then
                    ${sudo_command}rpm -ivh ${software} && say "install ${software} completed"  || say "Cannot install ${software}"
                elif [[ $software == *".deb" ]]; then
                    say "This package for ubuntu/debian, cannot install on this server"         && return $FALSE
                else
                    ${sudo_command}yum install -y ${software}
                fi
            elif [[ $osname == "alpine"* ]]; then
                ${sudo_command}apk add --no-cache ${software}
            elif [[ $osname == "opensuse"* ]]; then
                ${sudo_command}zypper install -n ${software}
            else
                say_err "Cannot install ${software}. OS not support."
                return $FALSE
            fi
        return $TRUE
    }

# install package
# example install tar: install_package tar
function    install_package()
    {
        software=${@}
            core_command_install
    }

# install multi package
function    install_packages()
    {
        for software in ${@}; do
            core_command_install
        done
    }

# install package have run bin
function    install_package_run()
    {
        software=${1}
            if ! machine_has ${software}; then
                core_command_install
            fi
        machine_has ${software}     && say "${software} installed."     || say_err "${software} not install."
        machine_has ${software}     && return $TRUE                     || return $FALSE
    }

# install multi packages have run bin
function    install_packages_run()
    {
        for software in ${@}; do
            if ! machine_has ${software}; then
                core_command_install
            fi
        machine_has ${software}     && say "${software} installed."     || say_err "${software} not install."
        machine_has ${software}     && return $TRUE                     || return $FALSE
        done
    }

# core command repo ubuntu-debian
function    core_command_debian_repo()
    {
        # osname=$(get_osname)
        get_osname
        say "add/delete repo ${software}.."
        is_root && sudo_command="" || sudo_command="sudo "
        command_extra=${command_extra:-""}
        software=${software:-""}
            if [[ $osname == "ubuntu"* || $osname == "debian"* ]]; then
                machine_has ${command_repo} || ${sudo_command}install_package software-properties-common
                ${sudo_command}${command_repo}${command_extra}${software}
            elif [[ $osname == "rhel"* ]]; then
                say "You using Redhat/Centos and cannot use"
                return $FALSE
            elif [[ $osname == "alpine"* ]]; then
                say "You using Alpine linux and cannot use"
                return $FALSE
            elif [[ $osname == "opensuse"* ]]; then
                say "You using Opensuse/Suse and cannot use"
                return $FALSE
            else
                say_err "OS not support."
                return $FALSE
            fi
        return $TRUE
    }

# add repo key
function    debian_add_repo_key()
    {
        software="${1}"
        command_repo="apt-key"
        server_key=keyserver.ubuntu.com
        command_extra=" adv --keyserver ${server_key} --recv-keys"
            if [[ $software == "http"* ]]; then
                machine_has curl && curl -s ${software} | apt-key add - || wget --quiet -O - ${software} | apt-key add -
            else
                core_command_debian_repo
            fi
    }

alias debian_add_repokey=debian_add_repo_key

# add multi repo keys
function    debian_add_repo_keys()
    {
        for software in "${@}"; do
            command_repo="apt-key"
            server_key=${server_key:-keyserver.ubuntu.com}
            command_extra=" adv --keyserver ${server_key} --recv-keys"
                if [[ $software == "http"* ]]; then
                    machine_has curl && curl -s ${software} | apt-key add - || wget --quiet -O - ${software} | apt-key add -
                else
                    core_command_debian_repo
                fi
        done
    }

alias debian_add_repokeys=debian_add_repo_keys

# add repo key
function    debian_list_repo_key()
    {
        command_repo="apt-key"
        command_extra=" list"
            core_command_debian_repo
    }

alias debian_list_repokey=debian_list_repo_key
alias debian_ls_repokey=debian_list_repo_key

# remove repo key
function    debian_remove_repo_key()
    {
        software=" ${1}"
        command_repo="apt-key"
        command_extra=" del"
            core_command_debian_repo
    }

alias debian_del_repo_key=debian_remove_repo_key
alias debian_delete_repo_key=debian_remove_repo_key
alias debian_remove_repokey=debian_remove_repo_key
alias debian_del_repokey=debian_remove_repo_key
alias debian_delete_repokey=debian_remove_repo_key

# remove multi repo keys
function    debian_remove_repo_keys()
    {
        for software in " ${@}"; do
            command_repo="apt-key"
            command_extra=" del"
                core_command_debian_repo
        done
    }

alias debian_del_repo_keys=debian_remove_repo_keys
alias debian_delete_repo_keys=debian_remove_repo_keys
alias debian_remove_repokeys=debian_remove_repo_keys
alias debian_del_repokeys=debian_remove_repo_keys
alias debian_delete_repokeys=debian_remove_repo_keys

# add repo
function    debian_add_repo()
    {
        software="${1}"
        command_repo="add-apt-repository"
        command_extra=" -y ppa:"
            core_command_debian_repo
    }

# add multi repo
function    debian_add_repos()
    {
        for software in "${@}"; do
            command_repo="add-apt-repository"
                core_command_debian_repo
        done
    }

# remove repo
function    debian_remove_repo()
    {
        software="${1}"
        command_repo="add-apt-repository --remove"
            core_command_debian_repo
    }

# remove multi repo
function    debian_remove_repos()
    {
        for software in "${@}"; do
            command_repo="add-apt-repository --remove"
                core_command_debian_repo
        done
    }

# install desktop minimal
function    install_desktop_minimal()
    {
        # osname=$(get_osname)
        get_osname
        say "install ${software}.."
        is_root && sudo_command="" || sudo_command="sudo "
            if [[ $osname == "ubuntu"* || $osname == "debian"* ]]; then
                check_debian_need_update && ${sudo_command}apt-get update || say "no need update repo"
                ${sudo_command}apt-get install -y --no-install-recommends xubuntu-desktop
                ${sudo_command}apt-get install -y --no-install-recommends xinit xterm firefox
            elif [[ $osname == "rhel.6"* ]]; then
                install_epel
                ${sudo_command}yum -y groupinstall "Desktop" "Desktop Platform" "X Window System" "Fonts"
                ${sudo_command}yum -y install xinit xterm firefox
            elif [[ $osname == "rhel.7"* ]]; then
                install_epel
                ${sudo_command}yum -y groupinstall xfce "X Window system"
                ${sudo_command}yum -y install xinit xterm firefox
            elif [[ $osname == "alpine"* ]]; then
                ${sudo_command}apk add --no-cache xfce4 xf86-input xf86-input-mouse xf86-input-keyboard kbd firefox
            elif [[ $osname == "opensuse"* ]]; then
                ${sudo_command}zypper -n install patterns-openSUSE-xfce
                ${sudo_command}zypper -n install xinit xterm firefox
            else
                say_err "Cannot install Desktop. OS not support."
                return $FALSE
            fi
        return $TRUE
    }

# install curl
function    install_curl()
    {
        install_package_run curl
    }

# install wget
function    install_wget()
    {
        install_package_run wget
    }

# export environment java
function    env_openjdk_jre()
    {
        export  JAVA_HOME=/usr/lib/jvm/java-1.${OPENJDKV}-openjdk/jre
	    export  PATH=$PATH:/usr/lib/jvm/java-1.${OPENJDKV}-openjdk/jre/bin:/usr/lib/jvm/java-1.${OPENJDKV}-openjdk/bin
    }

# install openjdk java jre
function    install_java_jre()
    {
        OPENJDKV=${OPENJDKV:-8}
        env_openjdk_jre
        if ! check_folder /usr/lib/jvm/java-1.${OPENJDKV}-openjdk/jre; then
        # osname=$(get_osname)
        get_osname
                if [[ $osname == "ubuntu"* || $osname == "debian"* ]]; then
                    software=openjdk-${OPENJDKV}-jre
                elif [[ $osname == "rhel"* ]]; then
                    software=java-1.${OPENJDKV}.0-openjdk.${arch}
                elif [[ $osname == "alpine"* ]]; then
                    software=openjdk${OPENJDKV}-jre
                else
                    say_err "Cannot install ${software}. OS not support."
                    return $FALSE
                fi
            core_command_install
            check_folder /usr/lib/jvm/java-1.${OPENJDKV}-openjdk/jre && say "Install ${software} completed!" || return $FALSE
        fi
        return $TRUE
    }

# install Gosu
function    install_gosu()
    {
    GOSU_VERSION=1.11
    # install gosu on your OS linux
    if machine_has gosu; then
        say "GOSU installed."
    else
        # osname=$(get_osname)
        get_osname
            if [[ $osname == "ubuntu"* || $osname == "debian"* || $osname == "alpine"* ]]; then 
                FILE_TEMP=/usr/local/bin/gosu
            elif [[ $osname == "rhel"* || $osname == "opensuse"* ]]; then
                FILE_TEMP=/usr/bin/gosu
            else
                say_err "Cannot install Gosu. OS not support."
                return $FALSE
            fi
        $download_save ${FILE_TEMP} "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$(dpkgArch)"
        [[ -f ${FILE_TEMP} ]]           && say "download success"                   || return $FALSE
        chmod +x ${FILE_TEMP}           && gosu nobody true
        say "GOSU installed."
    fi
        return $TRUE
    }

# install sudo
function    install_sudo()
    {
       install_package_run sudo
    }

# install js-yaml
function    install_js-yaml()
    {
       JSYAML_VERSION=3.10.0
       is_root && sudo_command="" || sudo_command="sudo "
       ${sudo_command}${download_save} /js-yaml.js "https://github.com/nodeca/js-yaml/raw/${JSYAML_VERSION}/dist/js-yaml.js"
    }

# install supervisor
function    install_supervisor()
    {
       install_package supervisor
    }

# install tar
function    install_tar()
    {
       install_package_run tar
    }

# install rsync
function    install_rsync()
    {
       install_package_run rsync
    }

# install unzip
function    install_unzip()
    {
       install_package_run unzip
    }

# install dmidecode
function    install_dmidecode()
    {
       install_package_run dmidecode
    }

# install php composer
function    install_php_composer()
    {
       say "install php composer.."   
       machine_has php                  && say "check php done"                     || return $FALSE
       machine_has $download_tool       && say "check download tool done"           || return $FALSE
       machine_has composer             && say "php composer installed before!"     || $download_tool https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer
       return $TRUE
    }


    ####### Function Remove ########
    ################################

# Clean cache OS
function    clean_os()
    {
        say "Cleaning OS cache.."
        is_root && sudo_command="" || sudo_command="sudo "
    get_osname
 	if [[ -f /etc/redhat-release ]] || [[ $osname == "rhel"* ]]; then
        ${sudo_command}yum clean all
        say "Clean OS done"
 	elif [[ -f /etc/lsb-release ]] || [[ -f /etc/debian_version ]] || [[ $osname == "ubuntu"* || $osname == "debian"* ]]; then
        ${sudo_command}apt-get autoremove -y
        ${sudo_command}apt-get autoclean
        ${sudo_command}apt-get clean
        ${sudo_command}rm -rf /build
        ${sudo_command}rm -rf /tmp/* /var/tmp/*
        ${sudo_command}rm -rf /var/lib/apt/lists/*
        ${sudo_command}rm -f /etc/dpkg/dpkg.cfg.d/02apt-speedup
        say "Clean OS done"
 	elif [[ -f /etc/alpine-release ]] || [[ $osname == "alpine"* ]]; then
        say "Clean OS done"
    elif [[ $osname == "opensuse"* ]]; then
        ${sudo_command}zypper clean
        say "Clean OS done"
 	else
        say_err "Not support"
        return $FALSE
 	fi
    return $TRUE
    }

# command remove, core command for remove packages
function    core_command_remove()
    {
        # osname=$(get_osname)
        get_osname
        say "remove ${software}.."
        is_root && sudo_command="" || sudo_command="sudo "
            if [[ $osname == "ubuntu"* || $osname == "debian"* ]]; then
                ${sudo_command}apt-get purge -y ${software}
                ${sudo_command}apt-get autoremove -y
            elif [[ $osname == "rhel"* ]]; then
                ${sudo_command}yum remove -y ${software}
            elif [[ $osname == "alpine"* ]]; then
                ${sudo_command}apk del --purge ${software}
            elif [[ $osname == "opensuse"* ]]; then
                ${sudo_command}zypper remove -n ${software}
            else
                say_err "Cannot remove ${software}. OS not support."
                return $FALSE
            fi
        return $TRUE
    }

# remove package
function    remove_package()
    {
        software=${@}
            core_command_remove
    }

# remove packages
function    remove_packages()
    {
        for software in ${@}; do
            core_command_remove
        done
    }

alias remove_packages=remove_packages
alias del_package=remove_package
alias del_packages=remove_packages
alias delete_package=remove_package
alias delete_packages=remove_packages

# remove package run bin
function   remove_package_run()
    {
        software=${1}
            if machine_has ${software}; then
                core_command_remove
            fi
            machine_has ${software}          && say "${software} Cannot remove."    || say "${software} removed."
            machine_has ${software}          && return $FALSE                       || return $TRUE
    }

# remove package run bin
function   remove_packages_run()
    {
        for software in ${@}; do
            if machine_has ${software}; then
                core_command_remove
            fi
            machine_has ${software}          && say "${software} Cannot remove."    || say "${software} removed."
            machine_has ${software}          && return $FALSE                       || return $TRUE
        done
    }

alias remove_packages_run=remove_packages_run
alias del_package_run=remove_package_run
alias del_packages_run=remove_packages_run
alias delete_package_run=remove_package_run
alias delete_packages_run=remove_packages_run

# Clean packages
function    clean_package()
    {
        UNINSTALL=${UNINSTALL:-false}
        UNINSTALLAPP=${UNINSTALLAPP:-false}
        if ! check_value_false "${UNINSTALL}" || ! check_value_false "${UNINSTALLAPP}"; then
            software="${UNINSTALL} ${UNINSTALLAPP}"
            core_command_remove
        else
            say "not have apps need remove"            
        fi
    return $TRUE
    }

alias clean_packages=clean_package

# remove desktop minimal
function    remove_desktop_minimal()
    {
        # osname=$(get_osname)
        get_osname
        say "install ${software}.."
        is_root && sudo_command=""      || sudo_command="sudo "
            if  [[ $osname == "ubuntu"* || $osname == "debian"* ]]; then
                ${sudo_command}apt-get purge -y xubuntu-desktop
                ${sudo_command}apt-get purge -y xinit xterm firefox
            elif [[ $osname == "rhel.6"* ]];    then
                ${sudo_command}yum -y groupremove "Desktop" "Desktop Platform" "X Window System" "Fonts"
                ${sudo_command}yum -y remove xinit
            elif [[ $osname == "rhel.7"* ]];    then
                ${sudo_command}yum -y groupremove xfce "X Window system"
                ${sudo_command}yum -y remove xinit xterm firefox
            elif [[ $osname == "alpine"* ]];    then
                ${sudo_command}apk del --purge xfce4 xf86-input xf86-input-mouse xf86-input-keyboard kbd firefox
            elif [[ $osname == "opensuse"* ]];  then
                ${sudo_command}zypper -n remove patterns-openSUSE-xfce
                ${sudo_command}zypper -n remove xinit xterm firefox
            else
                say_err "Cannot install Desktop. OS not support."
                return $FALSE
            fi
        return $TRUE
    }

# remove openjdk java jre
function    remove_java_jre()
    {
        OPENJDKV=${OPENJDKV:-8}
        env_openjdk_jre
        if check_folder /usr/lib/jvm/java-1.${OPENJDKV}-openjdk/jre; then
        # osname=$(get_osname)
        get_osname
                if [[ $osname == "ubuntu"* || $osname == "debian"* ]]; then
                    software=openjdk-${OPENJDKV}-jre
                elif [[ $osname == "rhel"* ]]; then
                    software=java-1.${OPENJDKV}.0-openjdk.${arch}
                elif [[ $osname == "alpine"* ]]; then
                    software=openjdk${OPENJDKV}-jre
                else
                    say_err "Cannot remove ${software}. OS not support."
                    return $FALSE
                fi
            core_command_remove
            check_folder /usr/lib/jvm/java-1.${OPENJDKV}-openjdk/jre && return $FALSE || say "Install ${software} completed!"
        fi
        return $TRUE
    }

alias delete_java_jre=remove_java_jre
alias del_java_jre=remove_java_jre

# remove Gosu
function    remove_gosu()
    {
    # install gosu on your OS linux
    if machine_has gosu; then
        say "GOSU installed."
    else
        # osname=$(get_osname)
        get_osname
            if [[ $osname == "ubuntu"* || $osname == "debian"* || $osname == "alpine"* ]]; then 
                FILE_TEMP=/usr/local/bin/gosu
            elif [[ $osname == "rhel"* ]]; then
                FILE_TEMP=/usr/bin/gosu
            else
                say_err "Cannot remove Gosu. OS not support."
                return $FALSE
            fi
        remove_file ${FILE_TEMP}
        [[ -f ${FILE_TEMP} ]]           && return $FALSE
        say "GOSU removed."
    fi
        return $TRUE
    }

alias delete_gosu=remove_gosu
alias del_gosu=remove_gosu

# remove sudo
function    remove_sudo()
    {
       remove_package_run sudo
    }

# remove js-yaml
function    remove_js-yaml()
    {
       remove_file /js-yaml.js
    }

alias delete_js-yaml=remove_js-yaml
alias del_js-yaml=remove_js-yaml

# remove supervisor
function    remove_supervisor()
    {
       remove_package supervisor
    }

alias delete_supervisor=remove_supervisor
alias del_supervisor=remove_supervisor

# remove tar
function    remove_tar()
    {
       remove_package_run tar
    }

alias delete_tar=remove_tar
alias del_tar=remove_tar

# remove rsync
function    remove_rsync()
    {
       remove_package_run rsync
    }

alias delete_rsync=remove_rsync
alias del_rsync=remove_rsync

# remove unzip
function    remove_unzip()
    {
       remove_package_run unzip
    }

alias delete_unzip=remove_unzip
alias del_unzip=remove_unzip

# remove dmidecode
function    remove_dmidecode()
    {
       remove_package_run dmidecode
    }

alias delete_dmidecode=remove_dmidecode
alias del_dmidecode=remove_dmidecode

# remove download tool
function    remove_download_tool()
    {
       remove_package_run $DOWNLOAD_TOOL
    }

alias delete_download_tool=remove_download_tool
alias del_download_tool=remove_download_tool
alias delete_downloadtool=remove_download_tool
alias del_downloadtool=remove_download_tool
alias remove_downloadtool=remove_download_tool

# remove php composer
function    remove_php_composer()
    {
        # remove composer
        remove_package_run composer
        # remove config, cache files
        remove_filefolders ~/.cache/composer ~/.local/share/composer ~/.config/composer
        remove_filefolder /root/.cache/composer /root/.local/share/composer /root/.config/composer
    }


# Group: Network
# ----------------------------------------------------#

## @fn is_ipv4()
## @ingroup network
## @brief Tests an IPv4 address.
## @param address Address to test.
## @retval 0 if the address is an IPv4.
## @retval 1 in others cases.
function    is_ipv4()
    {
        local -r regex='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'

        [[ ${1} =~ $regex ]]
        return $?
    }

## @fn is_fqdn()
## @ingroup network
## @brief Tests a FQDN.
## @param fqdn FQDN to test.
## @retval 0 if the FQDN is valid.
## @retval 1 in others cases.
function    is_fqdn()
    {
        echo "${1}" | grep -Pq '(?=^.{4,255}$)(^((?!-)[a-zA-Z0-9-]{1,63}(?<!-)\.)+[a-zA-Z]{2,63}\.?$)'

        return $?
    }

## @fn is_ipv4_netmask()
## @ingroup network
## @brief Tests if an IPv4 decimal netmask is valid.
## @param netmask IPv4 decimal netmask to test.
## @retval 0 if the IPv4 decimal netmask is valid.
## @retval 1 in others cases.
function    is_ipv4_netmask()
    {
        is_ipv4 "${1}" || return $FALSE

        IFS='.' read -r ipb[1] ipb[2] ipb[3] ipb[4] <<< "${1}"

        local -r list_msb='0 128 192 224 240 248 252 254'

        for i in {1,2,3,4}; do
            if [[ $rest_to_zero ]]; then
                [[ ${ipb[i]} -eq 0 ]] || return $FALSE
            else
                if [[ $list_msb =~ (^|[[:space:]])${ipb[i]}($|[[:space:]]) ]]; then
                    local -r rest_to_zero=1
                elif [[ ${ipb[i]} -eq 255 ]]; then
                    continue
                else
                    return $FALSE
                fi
            fi
        done

        return $TRUE
    }

## @fn is_ipv4_cidr()
## @ingroup network
## @brief Tests an IPv4 CIDR netmask.
## @param netmask CIDR netmask to test.
## @retval 0 if the IPv4 CIDR netmask is valid.
## @retval 1 in others cases.
function    is_ipv4_cidr()
    {
        local -r regex='^[[:digit:]]{1,2}$'

        [[ ${1} =~ $regex ]]        || return $FALSE
        [[ "${1}" -gt 32 ]]         || [[ "${1}" -lt 0 ]] && return $FALSE

        return $TRUE
    }

## @fn is_ipv4_subnet()
## @ingroup network
## @brief Tests an IPv4 subnet.
## @param subnet Subnet to test with /CIDR.
## @retval 0 if the IPv4 subnet is valid.
## @retval 1 in others cases.
function    is_ipv4_subnet()
    {
        IFS='/' read -r tip tmask <<< "${1}"

        is_ipv4_cidr "$tmask"       || return $FALSE
        is_ipv4 "$tip"              || return $FALSE

        return $TRUE
    }

## @fn get_ipv4_network()
## @ingroup network
## @brief Computes the network address of an IPv4 subnet.
## @param address IPv4 address.
## @param netmask IPv4 netmask.
## @retval 0 if the input parameters are valid.
## @retval 1 in others cases.
## @return Network address.
function    get_ipv4_network()
    {
        is_ipv4 "${1}"              || return $FALSE
        is_ipv4_netmask "${2}"      || return $FALSE

        IFS='.' read -r ipb1 ipb2 ipb3 ipb4 <<< "${1}"
        IFS='.' read -r mb1 mb2 mb3 mb4 <<< "${2}"

        echo "$((ipb1 & mb1)).$((ipb2 & mb2)).$((ipb3 & mb3)).$((ipb4 & mb4))"
    }

## @fn get_ipv4_broadcast()
## @ingroup network
## @brief Computes the broadcast address of an IPv4 subnet.
## @param address IPv4 address.
## @param netmask IPv4 netmask.
## @retval 0 if the input parameters are valid.
## @retval 1 in others cases.
## @return Broadcast address.
function    get_ipv4_broadcast()
    {
        is_ipv4 "${1}"              || return $FALSE
        is_ipv4_netmask "${2}"      || return $FALSE

        IFS='.' read -r ipb1 ipb2 ipb3 ipb4 <<< "${1}"
        IFS='.' read -r mb1 mb2 mb3 mb4 <<< "${2}"

        nmb1=$((mb1 ^ 255))
        nmb2=$((mb2 ^ 255))
        nmb3=$((mb3 ^ 255))
        nmb4=$((mb4 ^ 255))

        echo "$((ipb1 | nmb1)).$((ipb2 | nmb2)).$((ipb3 | nmb3)).$((ipb4 | nmb4))"
    }

## @fn mask2cidr()
## @ingroup network
## @brief Converts IPv4 decimal netmask notation into CIDR.
## @param netmask Decimal netmask to convert.
## @retval 0 if the input parameters are valid.
## @retval 1 in others cases.
## @return CIDR notation of the given decimal netmask.
function    mask2cidr()
    {
        is_ipv4_netmask "${1}"      || return $FALSE

        local x=${1##*255.}
        set -- 0^^^128^192^224^240^248^252^254^ $(( (${#1} - ${#x})*2 )) "${x%%.*}"
        x=${1%%$3*}
        echo $(( ${2} + (${#x}/4) ))
    }

## @fn cidr2mask()
## @ingroup network
## @brief Converts CIDR notation into IPv4 decimal netmask.
## @param netmask CIDR to convert.
## @retval 0 if the input parameters are valid.
## @retval 1 in others cases.
## @return Decimal notation of the given CIDR.
function    cidr2mask()
    {
        is_ipv4_cidr "${1}"         || return $FALSE

        local i mask=""
        local full_octets=$((${1}/8))
        local partial_octet=$((${1}%8))

        for ((i=0;i<4;i+=1)); do
            if [[ $i -lt $full_octets ]]; then
                mask+=255
            elif [[ $i -eq $full_octets ]]; then
                mask+=$((256 - 2**(8-partial_octet)))
            else
                mask+=0
            fi

            test $i -lt 3 && mask+=.
        done

        echo $mask
    }


    ####### Ending ########
    #######################
        export_all
    #######################